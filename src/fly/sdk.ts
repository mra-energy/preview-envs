import { GraphQLClient } from 'graphql-request'
type GraphQLClientRequestHeaders = Record<string, string>
import { print } from 'graphql'
import gql from 'graphql-tag'
export type Maybe<T> = T | null
export type InputMaybe<T> = Maybe<T>
export type Exact<T extends { [key: string]: unknown }> = {
  [K in keyof T]: T[K]
}
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]?: Maybe<T[SubKey]>
}
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
  [SubKey in K]: Maybe<T[SubKey]>
}
export type MakeEmpty<
  T extends { [key: string]: unknown },
  K extends keyof T
> = { [_ in K]?: never }
export type Incremental<T> =
  | T
  | {
      [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never
    }
type GraphQLError = {}
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string }
  String: { input: string; output: string }
  Boolean: { input: boolean; output: boolean }
  Int: { input: number; output: number }
  Float: { input: number; output: number }
  BigInt: { input: any; output: any }
  ISO8601DateTime: { input: any; output: any }
  JSON: { input: any; output: any }
}

export type AccessToken = Node & {
  __typename?: 'AccessToken'
  createdAt: Scalars['ISO8601DateTime']['output']
  id: Scalars['ID']['output']
  name: Scalars['String']['output']
  type: AccessTokenType
}

/** The connection type for AccessToken. */
export type AccessTokenConnection = {
  __typename?: 'AccessTokenConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AccessTokenEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AccessToken>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/** An edge in a connection. */
export type AccessTokenEdge = {
  __typename?: 'AccessTokenEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output']
  /** The item at the end of the edge. */
  node?: Maybe<AccessToken>
}

export enum AccessTokenType {
  /** used for querying access tokens */
  All = 'all',
  /** token generated for and used by flyctl */
  Flyctl = 'flyctl',
  /** token for fly-metrics.net */
  Grafana = 'grafana',
  /** personal access token generated in the UI */
  Pat = 'pat',
  /** used for Sentry */
  Sentry = 'sentry',
  /** access token */
  Token = 'token',
  /** token generated for our UI frontend */
  Ui = 'ui'
}

/** Autogenerated return type of AddCertificate. */
export type AddCertificatePayload = {
  __typename?: 'AddCertificatePayload'
  app?: Maybe<App>
  certificate?: Maybe<AppCertificate>
  check?: Maybe<HostnameCheck>
  errors?: Maybe<Array<Scalars['String']['output']>>
}

export type AddOn = Node & {
  __typename?: 'AddOn'
  /** The add-on plan */
  addOnPlan?: Maybe<AddOnPlan>
  /** The display name for an add-on plan */
  addOnPlanName?: Maybe<Scalars['String']['output']>
  /** An app associated with this add-on */
  app?: Maybe<App>
  /** Apps associated with this add-on */
  apps?: Maybe<AppConnection>
  /** Environment variables for the add-on */
  environment?: Maybe<Scalars['JSON']['output']>
  /** DNS hostname for the add-on */
  hostname?: Maybe<Scalars['String']['output']>
  id: Scalars['ID']['output']
  /** The service name according to the provider */
  name?: Maybe<Scalars['String']['output']>
  /** Add-on options */
  options?: Maybe<Scalars['JSON']['output']>
  /** Organization that owns this service */
  organization: Organization
  /** Password for the add-on */
  password?: Maybe<Scalars['String']['output']>
  /** Region where the primary instance is deployed */
  primaryRegion?: Maybe<Scalars['String']['output']>
  /** Private flycast IP address of the add-on */
  privateIp?: Maybe<Scalars['String']['output']>
  /** Public URL for this service */
  publicUrl?: Maybe<Scalars['String']['output']>
  /** Regions where replica instances are deployed */
  readRegions?: Maybe<Array<Scalars['String']['output']>>
  /** Single sign-on link to the add-on dashboard */
  ssoLink?: Maybe<Scalars['String']['output']>
  /** Redis database statistics */
  stats?: Maybe<Scalars['JSON']['output']>
  /** Status of the add-on */
  status?: Maybe<Scalars['String']['output']>
}

export type AddOnAppsArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

/** The connection type for AddOn. */
export type AddOnConnection = {
  __typename?: 'AddOnConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AddOnEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AddOn>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/** An edge in a connection. */
export type AddOnEdge = {
  __typename?: 'AddOnEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output']
  /** The item at the end of the edge. */
  node?: Maybe<AddOn>
}

export type AddOnPlan = Node & {
  __typename?: 'AddOnPlan'
  displayName?: Maybe<Scalars['String']['output']>
  id: Scalars['ID']['output']
  maxCommandsPerSec?: Maybe<Scalars['Int']['output']>
  maxConcurrentConnections?: Maybe<Scalars['Int']['output']>
  maxDailyBandwidth?: Maybe<Scalars['String']['output']>
  maxDailyCommands?: Maybe<Scalars['Int']['output']>
  maxDataSize?: Maybe<Scalars['String']['output']>
  maxRequestSize?: Maybe<Scalars['String']['output']>
  name?: Maybe<Scalars['String']['output']>
  pricePerMonth?: Maybe<Scalars['Int']['output']>
}

/** The connection type for AddOnPlan. */
export type AddOnPlanConnection = {
  __typename?: 'AddOnPlanConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AddOnPlanEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AddOnPlan>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/** An edge in a connection. */
export type AddOnPlanEdge = {
  __typename?: 'AddOnPlanEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output']
  /** The item at the end of the edge. */
  node?: Maybe<AddOnPlan>
}

export type AddOnProvider = {
  __typename?: 'AddOnProvider'
  asyncProvisioning: Scalars['Boolean']['output']
  autoProvision: Scalars['Boolean']['output']
  beta: Scalars['Boolean']['output']
  detectPlatform: Scalars['Boolean']['output']
  displayName?: Maybe<Scalars['String']['output']>
  excludedRegions?: Maybe<Array<Region>>
  id: Scalars['ID']['output']
  name?: Maybe<Scalars['String']['output']>
  nameSuffix?: Maybe<Scalars['String']['output']>
  provisioningInstructions?: Maybe<Scalars['String']['output']>
  regions?: Maybe<Array<Region>>
  resourceName: Scalars['String']['output']
  selectName: Scalars['Boolean']['output']
  selectRegion: Scalars['Boolean']['output']
  selectReplicaRegions: Scalars['Boolean']['output']
  tosAgreement?: Maybe<Scalars['String']['output']>
  tosUrl?: Maybe<Scalars['String']['output']>
}

export enum AddOnType {
  /** A PlanetScale database */
  Planetscale = 'planetscale',
  /** An Upstash Redis database */
  Redis = 'redis',
  /** A Sentry project endpoint */
  Sentry = 'sentry',
  /** A Supabase database */
  Supabase = 'supabase',
  /** An Upstash Redis database */
  UpstashRedis = 'upstash_redis'
}

/** Autogenerated input type of AddWireGuardPeer */
export type AddWireGuardPeerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The name with which to refer to the peer */
  name: Scalars['String']['input']
  /** Add via NATS transaction (deprecated - nats is always used) */
  nats?: InputMaybe<Scalars['Boolean']['input']>
  /** Network ID to attach wireguard peer to */
  network?: InputMaybe<Scalars['String']['input']>
  /** The node ID of the organization */
  organizationId: Scalars['ID']['input']
  /** The 25519 public key for the peer */
  pubkey: Scalars['String']['input']
  /** The region in which to deploy the peer */
  region?: InputMaybe<Scalars['String']['input']>
}

/** Autogenerated return type of AddWireGuardPeer. */
export type AddWireGuardPeerPayload = {
  __typename?: 'AddWireGuardPeerPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  endpointip: Scalars['String']['output']
  network?: Maybe<Scalars['String']['output']>
  peerip: Scalars['String']['output']
  pubkey: Scalars['String']['output']
}

/** Autogenerated input type of AllocateIPAddress */
export type AllocateIpAddressInput = {
  /** The application to allocate the ip address for */
  appId: Scalars['ID']['input']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The target network name in the specified organization */
  network?: InputMaybe<Scalars['String']['input']>
  /** The organization whose network should be used for private IP allocation */
  organizationId?: InputMaybe<Scalars['ID']['input']>
  /** Desired IP region (defaults to global) */
  region?: InputMaybe<Scalars['String']['input']>
  /** The name of the associated service */
  serviceName?: InputMaybe<Scalars['String']['input']>
  /** The type of IP address to allocate (v4, v6, or private_v6) */
  type: IpAddressType
}

/** Autogenerated return type of AllocateIPAddress. */
export type AllocateIpAddressPayload = {
  __typename?: 'AllocateIPAddressPayload'
  app: App
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  ipAddress?: Maybe<IpAddress>
}

export type Allocation = Node & {
  __typename?: 'Allocation'
  attachedVolumes: VolumeConnection
  canary: Scalars['Boolean']['output']
  checks: Array<CheckState>
  createdAt: Scalars['ISO8601DateTime']['output']
  criticalCheckCount: Scalars['Int']['output']
  /** Desired status */
  desiredStatus: Scalars['String']['output']
  events: Array<AllocationEvent>
  failed: Scalars['Boolean']['output']
  healthy: Scalars['Boolean']['output']
  /** Unique ID for this instance */
  id: Scalars['ID']['output']
  /** Short unique ID for this instance */
  idShort: Scalars['ID']['output']
  /** Indicates if this instance is from the latest job version */
  latestVersion: Scalars['Boolean']['output']
  passingCheckCount: Scalars['Int']['output']
  /** Private IPv6 address for this instance */
  privateIP?: Maybe<Scalars['String']['output']>
  recentLogs: Array<LogEntry>
  /** Region this allocation is running in */
  region: Scalars['String']['output']
  restarts: Scalars['Int']['output']
  /** Current status */
  status: Scalars['String']['output']
  taskName: Scalars['String']['output']
  totalCheckCount: Scalars['Int']['output']
  transitioning: Scalars['Boolean']['output']
  updatedAt: Scalars['ISO8601DateTime']['output']
  /** The configuration version of this instance */
  version: Scalars['Int']['output']
  warningCheckCount: Scalars['Int']['output']
}

export type AllocationAttachedVolumesArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

export type AllocationChecksArgs = {
  name?: InputMaybe<Scalars['String']['input']>
}

export type AllocationRecentLogsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  range?: InputMaybe<Scalars['Int']['input']>
}

export type AllocationEvent = {
  __typename?: 'AllocationEvent'
  message: Scalars['String']['output']
  timestamp: Scalars['ISO8601DateTime']['output']
  type: Scalars['String']['output']
}

export type App = Node & {
  __typename?: 'App'
  addOns: AddOnConnection
  allocation?: Maybe<Allocation>
  allocations: Array<Allocation>
  appUrl?: Maybe<Scalars['String']['output']>
  autoscaling?: Maybe<AutoscalingConfig>
  backupRegions: Array<Region>
  /**
   * [DEPRECATED] Builds of this application
   * @deprecated Superseded by source_builds
   */
  builds: BuildConnection
  /** Find a certificate by hostname */
  certificate?: Maybe<AppCertificate>
  /** Certificates for this app */
  certificates: AppCertificateConnection
  /** Changes to this application */
  changes: AppChangeConnection
  config: AppConfig
  createdAt: Scalars['ISO8601DateTime']['output']
  currentLock?: Maybe<AppLock>
  currentPlacement: Array<RegionPlacement>
  /** The latest release of this application */
  currentRelease?: Maybe<Release>
  /** The latest release of this application, without any config processing */
  currentReleaseUnprocessed?: Maybe<ReleaseUnprocessed>
  deployed: Scalars['Boolean']['output']
  /** Continuous deployment configuration */
  deploymentSource?: Maybe<DeploymentSource>
  /** Find a deployment by id, defaults to latest */
  deploymentStatus?: Maybe<DeploymentStatus>
  /** Check if this app has a configured deployment source */
  hasDeploymentSource: Scalars['Boolean']['output']
  healthChecks: CheckStateConnection
  /** Autogenerated hostname for this application */
  hostname?: Maybe<Scalars['String']['output']>
  /** Unique application ID */
  id: Scalars['ID']['output']
  /** Resolve an image from a reference */
  image?: Maybe<Image>
  /** Image details */
  imageDetails?: Maybe<ImageVersion>
  imageUpgradeAvailable?: Maybe<Scalars['Boolean']['output']>
  imageVersionTrackingEnabled: Scalars['Boolean']['output']
  /** Authentication key to use with Instrumentation endpoints */
  instrumentsKey?: Maybe<Scalars['String']['output']>
  internalId: Scalars['String']['output']
  internalNumericId: Scalars['Int']['output']
  /** Find an ip address by address string */
  ipAddress?: Maybe<IpAddress>
  ipAddresses: IpAddressConnection
  /** This object's unique key */
  key: Scalars['String']['output']
  /** Latest image details */
  latestImageDetails?: Maybe<ImageVersion>
  limitedAccessTokens: LimitedAccessTokenConnection
  machine?: Maybe<Machine>
  machines: MachineConnection
  /** The unique application name */
  name: Scalars['String']['output']
  network?: Maybe<Scalars['String']['output']>
  networkId?: Maybe<Scalars['Int']['output']>
  /** Organization that owns this app */
  organization: Organization
  parseConfig: AppConfig
  /** Fly platform version */
  platformVersion?: Maybe<PlatformVersionEnum>
  processGroups: Array<ProcessGroup>
  regions: Array<Region>
  /** Find a specific release */
  release?: Maybe<Release>
  /** Individual releases for this application */
  releases: ReleaseConnection
  /** Individual releases for this application, without any config processing */
  releasesUnprocessed: ReleaseUnprocessedConnection
  role?: Maybe<AppRole>
  /** Application runtime */
  runtime: RuntimeType
  /** Secrets set on the application */
  secrets: Array<Secret>
  services: Array<Service>
  sharedIpAddress?: Maybe<Scalars['String']['output']>
  state: AppState
  /** Application status */
  status: Scalars['String']['output']
  taskGroupCounts: Array<TaskGroupCount>
  usage: Array<AppUsage>
  version: Scalars['Int']['output']
  vmSize: VmSize
  vms: VmConnection
  volume?: Maybe<Volume>
  /** Volumes associated with app */
  volumes: VolumeConnection
}

export type AppAddOnsArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
  type?: InputMaybe<AddOnType>
}

export type AppAllocationArgs = {
  id: Scalars['String']['input']
}

export type AppAllocationsArgs = {
  showCompleted?: InputMaybe<Scalars['Boolean']['input']>
}

export type AppBuildsArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

export type AppCertificateArgs = {
  hostname: Scalars['String']['input']
}

export type AppCertificatesArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  filter?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  id?: InputMaybe<Scalars['String']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

export type AppChangesArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

export type AppDeploymentStatusArgs = {
  evaluationId?: InputMaybe<Scalars['String']['input']>
  id?: InputMaybe<Scalars['ID']['input']>
}

export type AppHealthChecksArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
  name?: InputMaybe<Scalars['String']['input']>
}

export type AppImageArgs = {
  ref: Scalars['String']['input']
}

export type AppIpAddressArgs = {
  address: Scalars['String']['input']
}

export type AppIpAddressesArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

export type AppLimitedAccessTokensArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

export type AppMachineArgs = {
  id: Scalars['String']['input']
}

export type AppMachinesArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
  version?: InputMaybe<Scalars['Int']['input']>
}

export type AppParseConfigArgs = {
  definition: Scalars['JSON']['input']
}

export type AppReleaseArgs = {
  id?: InputMaybe<Scalars['ID']['input']>
  version?: InputMaybe<Scalars['Int']['input']>
}

export type AppReleasesArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

export type AppReleasesUnprocessedArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
  status?: InputMaybe<Scalars['String']['input']>
}

export type AppVmsArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
  showCompleted?: InputMaybe<Scalars['Boolean']['input']>
}

export type AppVolumeArgs = {
  internalId: Scalars['String']['input']
}

export type AppVolumesArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

export type AppCertificate = Node & {
  __typename?: 'AppCertificate'
  /** @deprecated use isAcmeAlpnConfigured */
  acmeAlpnConfigured: Scalars['Boolean']['output']
  /** @deprecated use isAcmeDNSConfigured */
  acmeDnsConfigured: Scalars['Boolean']['output']
  certificateAuthority?: Maybe<Scalars['String']['output']>
  certificateRequestedAt?: Maybe<Scalars['ISO8601DateTime']['output']>
  check: Scalars['Boolean']['output']
  clientStatus: Scalars['String']['output']
  /** @deprecated use isConfigured */
  configured: Scalars['Boolean']['output']
  createdAt?: Maybe<Scalars['ISO8601DateTime']['output']>
  dnsProvider?: Maybe<Scalars['String']['output']>
  dnsValidationHostname: Scalars['String']['output']
  dnsValidationInstructions: Scalars['String']['output']
  dnsValidationTarget: Scalars['String']['output']
  domain?: Maybe<Scalars['String']['output']>
  hostname: Scalars['String']['output']
  id: Scalars['ID']['output']
  isAcmeAlpnConfigured: Scalars['Boolean']['output']
  isAcmeDnsConfigured: Scalars['Boolean']['output']
  isApex: Scalars['Boolean']['output']
  isConfigured: Scalars['Boolean']['output']
  isWildcard: Scalars['Boolean']['output']
  issued: CertificateConnection
  source?: Maybe<Scalars['String']['output']>
  validationErrors: Array<AppCertificateValidationError>
}

export type AppCertificateIssuedArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  includeExpired?: InputMaybe<Scalars['Boolean']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

/** The connection type for AppCertificate. */
export type AppCertificateConnection = {
  __typename?: 'AppCertificateConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AppCertificateEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AppCertificate>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/** An edge in a connection. */
export type AppCertificateEdge = {
  __typename?: 'AppCertificateEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output']
  /** The item at the end of the edge. */
  node?: Maybe<AppCertificate>
}

export type AppCertificateValidationError = {
  __typename?: 'AppCertificateValidationError'
  message: Scalars['String']['output']
  timestamp: Scalars['ISO8601DateTime']['output']
}

export type AppChange = Node & {
  __typename?: 'AppChange'
  /** Object that triggered the change */
  actor?: Maybe<AppChangeActor>
  actorType: Scalars['String']['output']
  app: App
  createdAt: Scalars['ISO8601DateTime']['output']
  description: Scalars['String']['output']
  id: Scalars['ID']['output']
  status?: Maybe<Scalars['String']['output']>
  updatedAt: Scalars['ISO8601DateTime']['output']
  user?: Maybe<User>
}

/** Objects that change apps */
export type AppChangeActor = Build | Release | Secret

/** The connection type for AppChange. */
export type AppChangeConnection = {
  __typename?: 'AppChangeConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AppChangeEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<AppChange>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/** An edge in a connection. */
export type AppChangeEdge = {
  __typename?: 'AppChangeEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output']
  /** The item at the end of the edge. */
  node?: Maybe<AppChange>
}

export type AppConfig = {
  __typename?: 'AppConfig'
  definition: Scalars['JSON']['output']
  errors: Array<Scalars['String']['output']>
  services: Array<Service>
  valid: Scalars['Boolean']['output']
}

/** The connection type for App. */
export type AppConnection = {
  __typename?: 'AppConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AppEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<App>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/** An edge in a connection. */
export type AppEdge = {
  __typename?: 'AppEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output']
  /** The item at the end of the edge. */
  node?: Maybe<App>
}

/** app lock */
export type AppLock = {
  __typename?: 'AppLock'
  /** Time when the lock expires */
  expiration: Scalars['ISO8601DateTime']['output']
  /** Lock ID */
  lockId: Scalars['ID']['output']
}

export type AppRole = {
  /** The name of this role */
  name: Scalars['String']['output']
}

export enum AppState {
  /** App has been deployed */
  Deployed = 'DEPLOYED',
  /** App has not been deployed */
  Pending = 'PENDING',
  /** App has been suspended */
  Suspended = 'SUSPENDED'
}

/** Application usage data */
export type AppUsage = {
  __typename?: 'AppUsage'
  /** The timespan interval for this usage sample */
  interval: Scalars['String']['output']
  /** Total requests for this time period */
  requestsCount: Scalars['Int']['output']
  /** Total app execution time (in seconds) for this time period */
  totalAppExecS: Scalars['Int']['output']
  /** Total GB transferred out in this time period */
  totalDataOutGB: Scalars['Float']['output']
  /** The start of the timespan for this usage sample */
  ts: Scalars['ISO8601DateTime']['output']
}

/** Autogenerated input type of AttachPostgresCluster */
export type AttachPostgresClusterInput = {
  /** The application to attach postgres to */
  appId: Scalars['ID']['input']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The database to attach. Defaults to a new database with the same name as the app. */
  databaseName?: InputMaybe<Scalars['String']['input']>
  /** The database user to create. Defaults to using the database name. */
  databaseUser?: InputMaybe<Scalars['String']['input']>
  /** Flag used to indicate that flyctl will exec calls */
  manualEntry?: InputMaybe<Scalars['Boolean']['input']>
  /** The postgres cluster application id */
  postgresClusterAppId: Scalars['ID']['input']
  /** The environment variable name to set the connection string to. Defaults to DATABASE_URL */
  variableName?: InputMaybe<Scalars['String']['input']>
}

/** Autogenerated return type of AttachPostgresCluster. */
export type AttachPostgresClusterPayload = {
  __typename?: 'AttachPostgresClusterPayload'
  app: App
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  connectionString: Scalars['String']['output']
  environmentVariableName: Scalars['String']['output']
  postgresClusterApp: App
}

export type AutoscaleRegionConfig = {
  __typename?: 'AutoscaleRegionConfig'
  /** The region code */
  code: Scalars['String']['output']
  /** The minimum number of VMs to run in this region */
  minCount?: Maybe<Scalars['Int']['output']>
  /** The relative weight for this region */
  weight?: Maybe<Scalars['Int']['output']>
}

/** Region autoscaling configuration */
export type AutoscaleRegionConfigInput = {
  /** The region code to configure */
  code: Scalars['String']['input']
  /** Minimum number of VMs to run in this region */
  minCount?: InputMaybe<Scalars['Int']['input']>
  /** Reset the configuration for this region */
  reset?: InputMaybe<Scalars['Boolean']['input']>
  /** The weight */
  weight?: InputMaybe<Scalars['Int']['input']>
}

export enum AutoscaleStrategy {
  /** place vms in regions near connection sources */
  ConnectionSources = 'CONNECTION_SOURCES',
  /** autoscaling is disabled */
  None = 'NONE',
  /** place vms in preferred regions by weight */
  PreferredRegions = 'PREFERRED_REGIONS'
}

export type AutoscalingConfig = {
  __typename?: 'AutoscalingConfig'
  backupRegions: Array<Scalars['String']['output']>
  balanceRegions: Scalars['Boolean']['output']
  enabled: Scalars['Boolean']['output']
  maxCount: Scalars['Int']['output']
  minCount: Scalars['Int']['output']
  preferredRegion?: Maybe<Scalars['String']['output']>
  regions: Array<AutoscaleRegionConfig>
  strategy: AutoscaleStrategy
}

export enum BillingStatus {
  Current = 'CURRENT',
  PastDue = 'PAST_DUE',
  SourceRequired = 'SOURCE_REQUIRED'
}

export type Build = Node & {
  __typename?: 'Build'
  app: App
  commitId?: Maybe<Scalars['String']['output']>
  commitUrl?: Maybe<Scalars['String']['output']>
  createdAt: Scalars['ISO8601DateTime']['output']
  /** The user who initiated the build */
  createdBy?: Maybe<User>
  /** Indicates if this build is complete and failed */
  failed: Scalars['Boolean']['output']
  id: Scalars['ID']['output']
  image?: Maybe<Scalars['String']['output']>
  /** Indicates if this build is currently in progress */
  inProgress: Scalars['Boolean']['output']
  /** Log output */
  logs: Scalars['String']['output']
  number: Scalars['Int']['output']
  /** Status of the build */
  status: Scalars['String']['output']
  /** Indicates if this build is complete and succeeded */
  succeeded: Scalars['Boolean']['output']
  updatedAt: Scalars['ISO8601DateTime']['output']
}

/** The connection type for Build. */
export type BuildConnection = {
  __typename?: 'BuildConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BuildEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Build>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/** An edge in a connection. */
export type BuildEdge = {
  __typename?: 'BuildEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output']
  /** The item at the end of the edge. */
  node?: Maybe<Build>
}

export type BuildFinalImageInput = {
  /** Sha256 id of docker image */
  id: Scalars['String']['input']
  /** Size in bytes of the docker image */
  sizeBytes: Scalars['BigInt']['input']
  /** Tag used for docker image */
  tag: Scalars['String']['input']
}

export type BuildImageOptsInput = {
  /** Set of build time variables passed to cli */
  buildArgs?: InputMaybe<Scalars['JSON']['input']>
  /** Fly.toml build.buildpacks setting */
  buildPacks?: InputMaybe<Array<Scalars['String']['input']>>
  /** Fly.toml build.builder setting */
  builder?: InputMaybe<Scalars['String']['input']>
  /** Builtin builder to use */
  builtIn?: InputMaybe<Scalars['String']['input']>
  /** Builtin builder settings */
  builtInSettings?: InputMaybe<Scalars['JSON']['input']>
  /** Path to dockerfile, if one exists */
  dockerfilePath?: InputMaybe<Scalars['String']['input']>
  /** Unused in cli? */
  extraBuildArgs?: InputMaybe<Scalars['JSON']['input']>
  /** Image label to use when tagging and pushing to the fly registry */
  imageLabel?: InputMaybe<Scalars['String']['input']>
  /** Unused in cli? */
  imageRef?: InputMaybe<Scalars['String']['input']>
  /** Do not use the build cache when building the image */
  noCache?: InputMaybe<Scalars['Boolean']['input']>
  /** Whether publishing to the registry was requested */
  publish?: InputMaybe<Scalars['Boolean']['input']>
  /** Docker tag used to publish image to registry */
  tag?: InputMaybe<Scalars['String']['input']>
  /** Set the target build stage to build if the Dockerfile has more than one stage */
  target?: InputMaybe<Scalars['String']['input']>
}

export type BuildStrategyAttemptInput = {
  /** Optional error message from strategy */
  error?: InputMaybe<Scalars['String']['input']>
  /** Optional note about this strategy or its result */
  note?: InputMaybe<Scalars['String']['input']>
  /** Result attempting this strategy */
  result: Scalars['String']['input']
  /** Build strategy attempted */
  strategy: Scalars['String']['input']
}

export type BuildTimingsInput = {
  /** Time to build and push the image, measured by flyctl */
  buildAndPushMs?: InputMaybe<Scalars['BigInt']['input']>
  /** Time to build the image including create context, measured by flyctl */
  buildMs?: InputMaybe<Scalars['BigInt']['input']>
  /** Time to initialize client used to connect to either remote or local builder */
  builderInitMs?: InputMaybe<Scalars['BigInt']['input']>
  /** Time to create the build context tar file, measured by flyctl */
  contextBuildMs?: InputMaybe<Scalars['BigInt']['input']>
  /** Time for builder to build image after receiving context, measured by flyctl */
  imageBuildMs?: InputMaybe<Scalars['BigInt']['input']>
  /** Time to push completed image to registry, measured by flyctl */
  pushMs?: InputMaybe<Scalars['BigInt']['input']>
}

export type BuilderMetaInput = {
  /** Local or remote builder type */
  builderType: Scalars['String']['input']
  /** Whther or not buildkit is enabled on builder */
  buildkitEnabled?: InputMaybe<Scalars['Boolean']['input']>
  /** Docker version reported by builder */
  dockerVersion?: InputMaybe<Scalars['String']['input']>
  /** Platform reported by the builder */
  platform?: InputMaybe<Scalars['String']['input']>
  /** Remote builder app used */
  remoteAppName?: InputMaybe<Scalars['ID']['input']>
  /** Remote builder machine used */
  remoteMachineId?: InputMaybe<Scalars['ID']['input']>
}

/** Autogenerated return type of CancelBuild. */
export type CancelBuildPayload = {
  __typename?: 'CancelBuildPayload'
  build: Build
}

export type Certificate = Node & {
  __typename?: 'Certificate'
  expiresAt: Scalars['ISO8601DateTime']['output']
  hostname: Scalars['String']['output']
  id: Scalars['ID']['output']
  type: Scalars['String']['output']
}

/** The connection type for Certificate. */
export type CertificateConnection = {
  __typename?: 'CertificateConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CertificateEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Certificate>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/** An edge in a connection. */
export type CertificateEdge = {
  __typename?: 'CertificateEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output']
  /** The item at the end of the edge. */
  node?: Maybe<Certificate>
}

/** health check */
export type Check = {
  __typename?: 'Check'
  httpHeaders?: Maybe<Array<CheckHeader>>
  httpMethod?: Maybe<Scalars['String']['output']>
  httpPath?: Maybe<Scalars['String']['output']>
  httpProtocol?: Maybe<HttpProtocol>
  httpTlsSkipVerify?: Maybe<Scalars['Boolean']['output']>
  /** Check interval in milliseconds */
  interval: Scalars['Int']['output']
  name?: Maybe<Scalars['String']['output']>
  scriptArgs?: Maybe<Array<Scalars['String']['output']>>
  scriptCommand?: Maybe<Scalars['String']['output']>
  /** Check timeout in milliseconds */
  timeout: Scalars['Int']['output']
  type: CheckType
}

/** Autogenerated input type of CheckCertificate */
export type CheckCertificateInput = {
  /** Application to ID */
  appId: Scalars['ID']['input']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** Certificate hostname to check */
  hostname: Scalars['String']['input']
}

/** Autogenerated return type of CheckCertificate. */
export type CheckCertificatePayload = {
  __typename?: 'CheckCertificatePayload'
  app?: Maybe<App>
  certificate?: Maybe<AppCertificate>
  check?: Maybe<HostnameCheck>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
}

/** Autogenerated input type of CheckDomain */
export type CheckDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** Domain name to check */
  domainName: Scalars['String']['input']
}

/** Autogenerated return type of CheckDomain. */
export type CheckDomainPayload = {
  __typename?: 'CheckDomainPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  dnsAvailable: Scalars['Boolean']['output']
  domainName: Scalars['String']['output']
  registrationAvailable: Scalars['Boolean']['output']
  registrationPeriod?: Maybe<Scalars['Int']['output']>
  registrationPrice?: Maybe<Scalars['Int']['output']>
  registrationSupported: Scalars['Boolean']['output']
  tld: Scalars['String']['output']
  transferAvailable: Scalars['Boolean']['output']
}

/** check job http response */
export type CheckHttpResponse = Node & {
  __typename?: 'CheckHTTPResponse'
  closeTs: Scalars['String']['output']
  connectedTs: Scalars['String']['output']
  dnsTs: Scalars['String']['output']
  firstTs: Scalars['String']['output']
  flyioDebug?: Maybe<Scalars['JSON']['output']>
  headers: Scalars['JSON']['output']
  id: Scalars['ID']['output']
  lastTs: Scalars['String']['output']
  location: CheckLocation
  rawHeaders: Scalars['String']['output']
  rawOutput: Array<Scalars['String']['output']>
  resolvedIp: Scalars['String']['output']
  sentTs: Scalars['String']['output']
  startTs: Scalars['String']['output']
  statusCode: Scalars['Int']['output']
  tlsTs?: Maybe<Scalars['String']['output']>
}

/** The connection type for CheckHTTPResponse. */
export type CheckHttpResponseConnection = {
  __typename?: 'CheckHTTPResponseConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CheckHttpResponseEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CheckHttpResponse>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/** An edge in a connection. */
export type CheckHttpResponseEdge = {
  __typename?: 'CheckHTTPResponseEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output']
  /** The item at the end of the edge. */
  node?: Maybe<CheckHttpResponse>
}

/** All available http checks verbs */
export enum CheckHttpVerb {
  Get = 'GET',
  Head = 'HEAD'
}

/** HTTP header for a health check */
export type CheckHeader = {
  __typename?: 'CheckHeader'
  name: Scalars['String']['output']
  value: Scalars['String']['output']
}

export type CheckHeaderInput = {
  name: Scalars['String']['input']
  value: Scalars['String']['input']
}

export type CheckInput = {
  httpHeaders?: InputMaybe<Array<CheckHeaderInput>>
  httpMethod?: InputMaybe<HttpMethod>
  httpPath?: InputMaybe<Scalars['String']['input']>
  httpProtocol?: InputMaybe<HttpProtocol>
  httpTlsSkipVerify?: InputMaybe<Scalars['Boolean']['input']>
  /** Check interval in milliseconds */
  interval?: InputMaybe<Scalars['Int']['input']>
  name?: InputMaybe<Scalars['String']['input']>
  scriptArgs?: InputMaybe<Array<Scalars['String']['input']>>
  scriptCommand?: InputMaybe<Scalars['String']['input']>
  /** Check timeout in milliseconds */
  timeout?: InputMaybe<Scalars['Int']['input']>
  type: CheckType
}

/** check job */
export type CheckJob = Node & {
  __typename?: 'CheckJob'
  httpOptions?: Maybe<CheckJobHttpOptions>
  id: Scalars['ID']['output']
  locations: CheckLocationConnection
  nextRunAt?: Maybe<Scalars['ISO8601DateTime']['output']>
  runs: CheckJobRunConnection
  schedule?: Maybe<Scalars['String']['output']>
  url: Scalars['String']['output']
}

/** check job */
export type CheckJobLocationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

/** check job */
export type CheckJobRunsArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

/** The connection type for CheckJob. */
export type CheckJobConnection = {
  __typename?: 'CheckJobConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CheckJobEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CheckJob>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/** An edge in a connection. */
export type CheckJobEdge = {
  __typename?: 'CheckJobEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output']
  /** The item at the end of the edge. */
  node?: Maybe<CheckJob>
}

/** health check state */
export type CheckJobHttpOptions = {
  __typename?: 'CheckJobHTTPOptions'
  headers: Array<Scalars['String']['output']>
  verb: CheckHttpVerb
}

/** health check state */
export type CheckJobHttpOptionsInput = {
  headers?: InputMaybe<Array<Scalars['String']['input']>>
  verb?: CheckHttpVerb
}

/** check job run */
export type CheckJobRun = Node & {
  __typename?: 'CheckJobRun'
  completedAt?: Maybe<Scalars['ISO8601DateTime']['output']>
  createdAt: Scalars['ISO8601DateTime']['output']
  httpOptions: CheckJobHttpOptions
  httpResponses: CheckHttpResponseConnection
  id: Scalars['ID']['output']
  locations: CheckLocationConnection
  state: Scalars['String']['output']
  tests: Array<Scalars['String']['output']>
  url: Scalars['String']['output']
}

/** check job run */
export type CheckJobRunHttpResponsesArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

/** check job run */
export type CheckJobRunLocationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

/** The connection type for CheckJobRun. */
export type CheckJobRunConnection = {
  __typename?: 'CheckJobRunConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CheckJobRunEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CheckJobRun>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/** An edge in a connection. */
export type CheckJobRunEdge = {
  __typename?: 'CheckJobRunEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output']
  /** The item at the end of the edge. */
  node?: Maybe<CheckJobRun>
}

/** check location */
export type CheckLocation = {
  __typename?: 'CheckLocation'
  coordinates: Array<Scalars['Float']['output']>
  country: Scalars['String']['output']
  locality: Scalars['String']['output']
  name: Scalars['String']['output']
  state?: Maybe<Scalars['String']['output']>
  title: Scalars['String']['output']
}

/** The connection type for CheckLocation. */
export type CheckLocationConnection = {
  __typename?: 'CheckLocationConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CheckLocationEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CheckLocation>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/** An edge in a connection. */
export type CheckLocationEdge = {
  __typename?: 'CheckLocationEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output']
  /** The item at the end of the edge. */
  node?: Maybe<CheckLocation>
}

/** health check state */
export type CheckState = {
  __typename?: 'CheckState'
  allocation: Allocation
  allocationId: Scalars['String']['output']
  name: Scalars['String']['output']
  output: Scalars['String']['output']
  serviceName: Scalars['String']['output']
  status: Scalars['String']['output']
  type: CheckType
  updatedAt: Scalars['ISO8601DateTime']['output']
}

/** health check state */
export type CheckStateOutputArgs = {
  compact?: InputMaybe<Scalars['Boolean']['input']>
  limit?: InputMaybe<Scalars['Int']['input']>
}

/** The connection type for CheckState. */
export type CheckStateConnection = {
  __typename?: 'CheckStateConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CheckStateEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<CheckState>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/** An edge in a connection. */
export type CheckStateEdge = {
  __typename?: 'CheckStateEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output']
  /** The item at the end of the edge. */
  node?: Maybe<CheckState>
}

export enum CheckType {
  /** http health check */
  Http = 'HTTP',
  /** script health check */
  Script = 'SCRIPT',
  /** tcp health check */
  Tcp = 'TCP'
}

/** Autogenerated input type of ConfigureRegions */
export type ConfigureRegionsInput = {
  /** Regions to allow running in */
  allowRegions?: InputMaybe<Array<Scalars['String']['input']>>
  /** The ID of the app */
  appId: Scalars['ID']['input']
  /** Fallback regions. Used if preferred regions are having issues */
  backupRegions?: InputMaybe<Array<Scalars['String']['input']>>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** Regions to deny running in */
  denyRegions?: InputMaybe<Array<Scalars['String']['input']>>
  /** Process group to modify */
  group?: InputMaybe<Scalars['String']['input']>
}

/** Autogenerated return type of ConfigureRegions. */
export type ConfigureRegionsPayload = {
  __typename?: 'ConfigureRegionsPayload'
  app: App
  backupRegions: Array<Region>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  group?: Maybe<Scalars['String']['output']>
  regions: Array<Region>
}

/** Autogenerated input type of CreateAddOn */
export type CreateAddOnInput = {
  /** An optional application ID to attach the add-on to after provisioning */
  appId?: InputMaybe<Scalars['ID']['input']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** An optional name for the add-on */
  name?: InputMaybe<Scalars['String']['input']>
  /** Options specific to the add-on */
  options?: InputMaybe<Scalars['JSON']['input']>
  /** The organization which owns the add-on */
  organizationId?: InputMaybe<Scalars['ID']['input']>
  /** The add-on plan ID */
  planId?: InputMaybe<Scalars['ID']['input']>
  /** Desired primary region for the add-on */
  primaryRegion?: InputMaybe<Scalars['String']['input']>
  /** Desired regions to place replicas in */
  readRegions?: InputMaybe<Array<Scalars['String']['input']>>
  /** The add-on type to provision */
  type: AddOnType
}

/** Autogenerated return type of CreateAddOn. */
export type CreateAddOnPayload = {
  __typename?: 'CreateAddOnPayload'
  addOn: AddOn
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
}

/** Autogenerated input type of CreateAndRegisterDomain */
export type CreateAndRegisterDomainInput = {
  /** Enable auto renew on the registration */
  autoRenew?: InputMaybe<Scalars['Boolean']['input']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The domain name */
  name: Scalars['String']['input']
  /** The node ID of the organization */
  organizationId: Scalars['ID']['input']
  /** Enable whois privacy on the registration */
  whoisPrivacy?: InputMaybe<Scalars['Boolean']['input']>
}

/** Autogenerated return type of CreateAndRegisterDomain. */
export type CreateAndRegisterDomainPayload = {
  __typename?: 'CreateAndRegisterDomainPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  domain: Domain
  organization: Organization
}

/** Autogenerated input type of CreateAndTransferDomain */
export type CreateAndTransferDomainInput = {
  /** The authorization code */
  authorizationCode: Scalars['String']['input']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The domain name */
  name: Scalars['String']['input']
  /** The node ID of the organization */
  organizationId: Scalars['ID']['input']
}

/** Autogenerated return type of CreateAndTransferDomain. */
export type CreateAndTransferDomainPayload = {
  __typename?: 'CreateAndTransferDomainPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  domain: Domain
  organization: Organization
}

/** Autogenerated input type of CreateApp */
export type CreateAppInput = {
  appRoleId?: InputMaybe<Scalars['String']['input']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  heroku?: InputMaybe<Scalars['Boolean']['input']>
  machines?: InputMaybe<Scalars['Boolean']['input']>
  /** The name of the new application. Defaults to a random name. */
  name?: InputMaybe<Scalars['String']['input']>
  network?: InputMaybe<Scalars['String']['input']>
  /** The node ID of the organization */
  organizationId: Scalars['ID']['input']
  preferredRegion?: InputMaybe<Scalars['String']['input']>
  /** The application runtime */
  runtime?: InputMaybe<RuntimeType>
}

/** Autogenerated return type of CreateApp. */
export type CreateAppPayload = {
  __typename?: 'CreateAppPayload'
  app: App
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
}

/** Autogenerated input type of CreateBuild */
export type CreateBuildInput = {
  /** The name of the app being built */
  appName: Scalars['ID']['input']
  /** Whether builder is remote or local */
  builderType: Scalars['String']['input']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** Options set for building image */
  imageOpts: BuildImageOptsInput
  /** The ID of the machine being built (only set for machine builds) */
  machineId?: InputMaybe<Scalars['ID']['input']>
  /** List of available build strategies that will be attempted */
  strategiesAvailable: Array<Scalars['String']['input']>
}

/** Autogenerated return type of CreateBuild. */
export type CreateBuildPayload = {
  __typename?: 'CreateBuildPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  /** build id */
  id: Scalars['ID']['output']
  /** stored build status */
  status: Scalars['String']['output']
}

/** Autogenerated input type of CreateCheckJob */
export type CreateCheckJobInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** http check options */
  httpOptions: CheckJobHttpOptionsInput
  /** http checks locations */
  locations: Array<Scalars['String']['input']>
  /** Organization ID */
  organizationId: Scalars['ID']['input']
  /** The URL to check */
  url: Scalars['String']['input']
}

/** Autogenerated return type of CreateCheckJob. */
export type CreateCheckJobPayload = {
  __typename?: 'CreateCheckJobPayload'
  checkJob: CheckJob
  checkJobRun?: Maybe<CheckJobRun>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
}

/** Autogenerated input type of CreateCheckJobRun */
export type CreateCheckJobRunInput = {
  /** Check Job ID */
  checkJobId: Scalars['ID']['input']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
}

/** Autogenerated return type of CreateCheckJobRun. */
export type CreateCheckJobRunPayload = {
  __typename?: 'CreateCheckJobRunPayload'
  checkJob: CheckJob
  checkJobRun?: Maybe<CheckJobRun>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
}

/** Autogenerated input type of CreateDNSPortal */
export type CreateDnsPortalInput = {
  /** The secondary branding color */
  accentColor?: InputMaybe<Scalars['String']['input']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The unique name of this portal. A random name will be generated if omitted. */
  name?: InputMaybe<Scalars['String']['input']>
  /** The node ID of the organization */
  organizationId: Scalars['ID']['input']
  /** The primary branding color */
  primaryColor?: InputMaybe<Scalars['String']['input']>
  /** The return url for this portal */
  returnUrl?: InputMaybe<Scalars['String']['input']>
  /** The text to display for the return url link */
  returnUrlText?: InputMaybe<Scalars['String']['input']>
  /** The support url for this portal */
  supportUrl?: InputMaybe<Scalars['String']['input']>
  /** The text to display for the support url link */
  supportUrlText?: InputMaybe<Scalars['String']['input']>
  /** The title of this portal */
  title?: InputMaybe<Scalars['String']['input']>
}

/** Autogenerated return type of CreateDNSPortal. */
export type CreateDnsPortalPayload = {
  __typename?: 'CreateDNSPortalPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  dnsPortal: DnsPortal
}

/** Autogenerated input type of CreateDNSPortalSession */
export type CreateDnsPortalSessionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The node ID of the dns portal */
  dnsPortalId: Scalars['ID']['input']
  /** The node ID of the domain to edit */
  domainId: Scalars['ID']['input']
  /** Optionally override the portal's default return url for this session */
  returnUrl?: InputMaybe<Scalars['String']['input']>
  /** Optionally override the portal's default return url text for this session */
  returnUrlText?: InputMaybe<Scalars['String']['input']>
  /** Optionally override the portal's default title for this session */
  title?: InputMaybe<Scalars['String']['input']>
}

/** Autogenerated return type of CreateDNSPortalSession. */
export type CreateDnsPortalSessionPayload = {
  __typename?: 'CreateDNSPortalSessionPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  dnsPortalSession: DnsPortalSession
}

/** Autogenerated input type of CreateDNSRecord */
export type CreateDnsRecordInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The node ID of the domain */
  domainId: Scalars['ID']['input']
  /** The dns record name */
  name: Scalars['String']['input']
  /** The content of the record */
  rdata: Scalars['String']['input']
  /** The TTL in seconds */
  ttl: Scalars['Int']['input']
  /** The type of the record */
  type: DnsRecordType
}

/** Autogenerated return type of CreateDNSRecord. */
export type CreateDnsRecordPayload = {
  __typename?: 'CreateDNSRecordPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  record: DnsRecord
}

/** Autogenerated input type of CreateDelegatedWireGuardToken */
export type CreateDelegatedWireGuardTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The name with which to refer to the peer */
  name?: InputMaybe<Scalars['String']['input']>
  /** The node ID of the organization */
  organizationId: Scalars['ID']['input']
}

/** Autogenerated return type of CreateDelegatedWireGuardToken. */
export type CreateDelegatedWireGuardTokenPayload = {
  __typename?: 'CreateDelegatedWireGuardTokenPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  token: Scalars['String']['output']
}

/** Autogenerated input type of CreateDoctorReport */
export type CreateDoctorReportInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The report data */
  data: Scalars['JSON']['input']
}

/** Autogenerated return type of CreateDoctorReport. */
export type CreateDoctorReportPayload = {
  __typename?: 'CreateDoctorReportPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  reportId: Scalars['ID']['output']
}

/** Autogenerated return type of CreateDoctorUrl. */
export type CreateDoctorUrlPayload = {
  __typename?: 'CreateDoctorUrlPayload'
  putUrl: Scalars['String']['output']
}

/** Autogenerated input type of CreateDomain */
export type CreateDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The domain name */
  name: Scalars['String']['input']
  /** The node ID of the organization */
  organizationId: Scalars['ID']['input']
}

/** Autogenerated return type of CreateDomain. */
export type CreateDomainPayload = {
  __typename?: 'CreateDomainPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  domain: Domain
  organization: Organization
}

/** Autogenerated input type of CreateExtensionTosAgreement */
export type CreateExtensionTosAgreementInput = {
  /** The add-on provider name */
  addOnProviderName: Scalars['String']['input']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The organization that agrees to the ToS */
  organizationId: Scalars['ID']['input']
}

/** Autogenerated return type of CreateExtensionTosAgreement. */
export type CreateExtensionTosAgreementPayload = {
  __typename?: 'CreateExtensionTosAgreementPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
}

/** Autogenerated input type of CreateLimitedAccessToken */
export type CreateLimitedAccessTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  expiry?: InputMaybe<Scalars['String']['input']>
  name: Scalars['String']['input']
  /** The node ID of the organization */
  organizationId: Scalars['ID']['input']
  profile: Scalars['String']['input']
  profileParams?: InputMaybe<Scalars['JSON']['input']>
}

/** Autogenerated return type of CreateLimitedAccessToken. */
export type CreateLimitedAccessTokenPayload = {
  __typename?: 'CreateLimitedAccessTokenPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  limitedAccessToken: LimitedAccessToken
}

/** Autogenerated input type of CreateOrganization */
export type CreateOrganizationInput = {
  /** Whether or not new apps in this org use Apps V2 by default */
  appsV2DefaultOn?: InputMaybe<Scalars['Boolean']['input']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The name of the organization */
  name: Scalars['String']['input']
}

/** Autogenerated input type of CreateOrganizationInvitation */
export type CreateOrganizationInvitationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The email to invite */
  email: Scalars['String']['input']
  /** The node ID of the organization */
  organizationId: Scalars['ID']['input']
}

/** Autogenerated return type of CreateOrganizationInvitation. */
export type CreateOrganizationInvitationPayload = {
  __typename?: 'CreateOrganizationInvitationPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  invitation: OrganizationInvitation
}

/** Autogenerated return type of CreateOrganization. */
export type CreateOrganizationPayload = {
  __typename?: 'CreateOrganizationPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  organization: Organization
}

/** Autogenerated input type of CreatePostgresClusterDatabase */
export type CreatePostgresClusterDatabaseInput = {
  /** The name of the postgres cluster app */
  appName: Scalars['String']['input']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The name of the database */
  databaseName: Scalars['String']['input']
}

/** Autogenerated return type of CreatePostgresClusterDatabase. */
export type CreatePostgresClusterDatabasePayload = {
  __typename?: 'CreatePostgresClusterDatabasePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  database: PostgresClusterDatabase
  postgresClusterRole: PostgresClusterAppRole
}

/** Autogenerated input type of CreatePostgresCluster */
export type CreatePostgresClusterInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** Number of VM's to provision */
  count?: InputMaybe<Scalars['Int']['input']>
  imageRef?: InputMaybe<Scalars['String']['input']>
  /** The name of the new application. Defaults to a random name. */
  name?: InputMaybe<Scalars['String']['input']>
  /** The node ID of the organization */
  organizationId: Scalars['ID']['input']
  /** The superuser password. Defaults to a random password. */
  password?: InputMaybe<Scalars['String']['input']>
  region?: InputMaybe<Scalars['String']['input']>
  snapshotId?: InputMaybe<Scalars['ID']['input']>
  /** The VM size to use. Defaults to shared-cpu-1x */
  vmSize?: InputMaybe<Scalars['String']['input']>
  /** The volume size in GB. Defaults to 10. */
  volumeSizeGb?: InputMaybe<Scalars['Int']['input']>
}

/** Autogenerated return type of CreatePostgresCluster. */
export type CreatePostgresClusterPayload = {
  __typename?: 'CreatePostgresClusterPayload'
  app: App
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  password: Scalars['String']['output']
  username: Scalars['String']['output']
}

/** Autogenerated input type of CreatePostgresClusterUser */
export type CreatePostgresClusterUserInput = {
  /** The name of the postgres cluster app */
  appName: Scalars['String']['input']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The password of the user */
  password: Scalars['String']['input']
  /** Should this user be a superuser */
  superuser?: InputMaybe<Scalars['Boolean']['input']>
  /** The name of the database */
  username: Scalars['String']['input']
}

/** Autogenerated return type of CreatePostgresClusterUser. */
export type CreatePostgresClusterUserPayload = {
  __typename?: 'CreatePostgresClusterUserPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  postgresClusterRole: PostgresClusterAppRole
  user: PostgresClusterUser
}

/** Autogenerated input type of CreateRelease */
export type CreateReleaseInput = {
  /** The ID of the app */
  appId: Scalars['ID']['input']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** app definition */
  definition: Scalars['JSON']['input']
  /** The image to deploy */
  image: Scalars['String']['input']
  /** nomad or machines */
  platformVersion: Scalars['String']['input']
  /** The strategy for replacing existing instances. Defaults to canary. */
  strategy: DeploymentStrategy
}

/** Autogenerated return type of CreateRelease. */
export type CreateReleasePayload = {
  __typename?: 'CreateReleasePayload'
  app: App
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  release?: Maybe<Release>
}

/** Autogenerated input type of CreateTemplateDeployment */
export type CreateTemplateDeploymentInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The node ID of the organization to move the app to */
  organizationId: Scalars['ID']['input']
  template: Scalars['JSON']['input']
  variables?: InputMaybe<Array<PropertyInput>>
}

/** Autogenerated return type of CreateTemplateDeployment. */
export type CreateTemplateDeploymentPayload = {
  __typename?: 'CreateTemplateDeploymentPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  templateDeployment: TemplateDeployment
}

/** Autogenerated input type of CreateVolume */
export type CreateVolumeInput = {
  /** The application to attach the new volume to */
  appId: Scalars['ID']['input']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** Volume should be encrypted at rest */
  encrypted?: InputMaybe<Scalars['Boolean']['input']>
  fsType?: InputMaybe<FsTypeType>
  /** Volume name */
  name: Scalars['String']['input']
  /** Desired region for volume */
  region: Scalars['String']['input']
  /** Provision volume in a redundancy zone not already in use by this app */
  requireUniqueZone?: InputMaybe<Scalars['Boolean']['input']>
  /** Desired volume size, in GB */
  sizeGb: Scalars['Int']['input']
  snapshotId?: InputMaybe<Scalars['ID']['input']>
}

/** Autogenerated return type of CreateVolume. */
export type CreateVolumePayload = {
  __typename?: 'CreateVolumePayload'
  app: App
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  volume: Volume
}

/** Autogenerated input type of CreateVolumeSnapshot */
export type CreateVolumeSnapshotInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  volumeId: Scalars['ID']['input']
}

/** Autogenerated return type of CreateVolumeSnapshot. */
export type CreateVolumeSnapshotPayload = {
  __typename?: 'CreateVolumeSnapshotPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  volume: Volume
}

export type DnsPortal = Node & {
  __typename?: 'DNSPortal'
  accentColor: Scalars['String']['output']
  createdAt: Scalars['ISO8601DateTime']['output']
  id: Scalars['ID']['output']
  name: Scalars['String']['output']
  organization: Organization
  primaryColor: Scalars['String']['output']
  returnUrl?: Maybe<Scalars['String']['output']>
  returnUrlText?: Maybe<Scalars['String']['output']>
  supportUrl?: Maybe<Scalars['String']['output']>
  supportUrlText?: Maybe<Scalars['String']['output']>
  title: Scalars['String']['output']
  updatedAt: Scalars['ISO8601DateTime']['output']
}

/** The connection type for DNSPortal. */
export type DnsPortalConnection = {
  __typename?: 'DNSPortalConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DnsPortalEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DnsPortal>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/** An edge in a connection. */
export type DnsPortalEdge = {
  __typename?: 'DNSPortalEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output']
  /** The item at the end of the edge. */
  node?: Maybe<DnsPortal>
}

export type DnsPortalSession = Node & {
  __typename?: 'DNSPortalSession'
  createdAt: Scalars['ISO8601DateTime']['output']
  /** The dns portal this session */
  dnsPortal: DnsPortal
  expiresAt: Scalars['ISO8601DateTime']['output']
  id: Scalars['ID']['output']
  /** Is this session expired? */
  isExpired: Scalars['Boolean']['output']
  /** The overridden return url for this session */
  returnUrl?: Maybe<Scalars['String']['output']>
  /** The overridden return url text for this session */
  returnUrlText?: Maybe<Scalars['String']['output']>
  /** The overridden title for this session */
  title?: Maybe<Scalars['String']['output']>
  /** The url to access this session's dns portal */
  url: Scalars['String']['output']
}

export type DnsRecord = Node & {
  __typename?: 'DNSRecord'
  createdAt: Scalars['ISO8601DateTime']['output']
  /** The domain this record belongs to */
  domain: Domain
  /** Fully qualified domain name for this record */
  fqdn: Scalars['String']['output']
  id: Scalars['ID']['output']
  /** Is this record at the zone apex? */
  isApex: Scalars['Boolean']['output']
  /** Is this a system record? System records are managed by fly and not editable. */
  isSystem: Scalars['Boolean']['output']
  /** Is this record a wildcard? */
  isWildcard: Scalars['Boolean']['output']
  /** The name of this record. @ indicates the record is at the zone apex. */
  name: Scalars['String']['output']
  /** The record data */
  rdata: Scalars['String']['output']
  /** The number of seconds this record can be cached for */
  ttl: Scalars['Int']['output']
  /** The type of record */
  type: DnsRecordType
  updatedAt: Scalars['ISO8601DateTime']['output']
}

export type DnsRecordAttributes = {
  __typename?: 'DNSRecordAttributes'
  /** The name of the record. */
  name: Scalars['String']['output']
  /** The record data. */
  rdata: Scalars['String']['output']
  /** The number of seconds this record can be cached for. */
  ttl: Scalars['Int']['output']
  /** The type of record. */
  type: DnsRecordType
}

export enum DnsRecordChangeAction {
  /** A record should be created with the provided attributes */
  Create = 'CREATE',
  /** A record with the provided ID should be deleted */
  Delete = 'DELETE',
  /** A record with the provided ID should be updated */
  Update = 'UPDATE'
}

export type DnsRecordChangeInput = {
  /** The action to perform on this record. */
  action: DnsRecordChangeAction
  /** The name of the record. If omitted it will default to @ - the zone apex. */
  name?: InputMaybe<Scalars['String']['input']>
  /** The record data. Required if action is CREATE */
  rdata?: InputMaybe<Scalars['String']['input']>
  /** The id of the record this action will apply to. This is required if the action is UPDATE or DELETE. */
  recordId?: InputMaybe<Scalars['ID']['input']>
  /** The number of seconds this record can be cached for. Defaults to 1 hour. */
  ttl?: InputMaybe<Scalars['Int']['input']>
  /** The record type. This is required if action is CREATE. */
  type?: InputMaybe<DnsRecordType>
}

/** The connection type for DNSRecord. */
export type DnsRecordConnection = {
  __typename?: 'DNSRecordConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DnsRecordEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DnsRecord>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export type DnsRecordDiff = {
  __typename?: 'DNSRecordDiff'
  /** The action that was performed. */
  action: DnsRecordChangeAction
  /** The attributes for this record after the action was performed. */
  newAttributes?: Maybe<DnsRecordAttributes>
  /** The text representation of this record after the action was performed. */
  newText?: Maybe<Scalars['String']['output']>
  /** The attributes for this record before the action was performed. */
  oldAttributes?: Maybe<DnsRecordAttributes>
  /** The text representation of this record before the action was performed. */
  oldText?: Maybe<Scalars['String']['output']>
}

/** An edge in a connection. */
export type DnsRecordEdge = {
  __typename?: 'DNSRecordEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output']
  /** The item at the end of the edge. */
  node?: Maybe<DnsRecord>
}

export enum DnsRecordType {
  A = 'A',
  Aaaa = 'AAAA',
  Alias = 'ALIAS',
  Cname = 'CNAME',
  Mx = 'MX',
  Ns = 'NS',
  Soa = 'SOA',
  Srv = 'SRV',
  Txt = 'TXT'
}

export type DnsRecordWarning = {
  __typename?: 'DNSRecordWarning'
  /** The action to perform. */
  action: DnsRecordChangeAction
  /** The desired attributes for this record. */
  attributes: DnsRecordAttributes
  /** The warning message. */
  message: Scalars['String']['output']
  /** The record this warning applies to. */
  record?: Maybe<DnsRecord>
}

export type DelegatedWireGuardToken = Node & {
  __typename?: 'DelegatedWireGuardToken'
  id: Scalars['ID']['output']
  name: Scalars['String']['output']
}

/** The connection type for DelegatedWireGuardToken. */
export type DelegatedWireGuardTokenConnection = {
  __typename?: 'DelegatedWireGuardTokenConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DelegatedWireGuardTokenEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<DelegatedWireGuardToken>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/** An edge in a connection. */
export type DelegatedWireGuardTokenEdge = {
  __typename?: 'DelegatedWireGuardTokenEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output']
  /** The item at the end of the edge. */
  node?: Maybe<DelegatedWireGuardToken>
}

/** Autogenerated input type of DeleteAddOn */
export type DeleteAddOnInput = {
  /** The ID of the add-on to delete */
  addOnId?: InputMaybe<Scalars['ID']['input']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The name of the add-on to delete */
  name?: InputMaybe<Scalars['String']['input']>
}

/** Autogenerated return type of DeleteAddOn. */
export type DeleteAddOnPayload = {
  __typename?: 'DeleteAddOnPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  deletedAddOnName?: Maybe<Scalars['String']['output']>
}

/** Autogenerated return type of DeleteApp. */
export type DeleteAppPayload = {
  __typename?: 'DeleteAppPayload'
  /** The organization that owned the deleted app */
  organization: Organization
}

/** Autogenerated return type of DeleteCertificate. */
export type DeleteCertificatePayload = {
  __typename?: 'DeleteCertificatePayload'
  app?: Maybe<App>
  certificate?: Maybe<AppCertificate>
  errors?: Maybe<Array<Scalars['String']['output']>>
}

/** Autogenerated input type of DeleteDNSPortal */
export type DeleteDnsPortalInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The node ID of the dns portal */
  dnsPortalId: Scalars['ID']['input']
}

/** Autogenerated return type of DeleteDNSPortal. */
export type DeleteDnsPortalPayload = {
  __typename?: 'DeleteDNSPortalPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  /** The organization that owned the dns portal */
  organization: Organization
}

/** Autogenerated input type of DeleteDNSPortalSession */
export type DeleteDnsPortalSessionInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The node ID of the dns portal session */
  dnsPortalSessionId: Scalars['ID']['input']
}

/** Autogenerated return type of DeleteDNSPortalSession. */
export type DeleteDnsPortalSessionPayload = {
  __typename?: 'DeleteDNSPortalSessionPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  /** The dns portal that owned the session */
  dnsPortal: DnsPortal
}

/** Autogenerated input type of DeleteDNSRecord */
export type DeleteDnsRecordInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The node ID of the DNS record */
  recordId: Scalars['ID']['input']
}

/** Autogenerated return type of DeleteDNSRecord. */
export type DeleteDnsRecordPayload = {
  __typename?: 'DeleteDNSRecordPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  domain: Domain
}

/** Autogenerated input type of DeleteDelegatedWireGuardToken */
export type DeleteDelegatedWireGuardTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The name with which to refer to the token */
  name?: InputMaybe<Scalars['String']['input']>
  /** The node ID of the organization */
  organizationId: Scalars['ID']['input']
  /** The raw WireGuard token */
  token?: InputMaybe<Scalars['String']['input']>
}

/** Autogenerated return type of DeleteDelegatedWireGuardToken. */
export type DeleteDelegatedWireGuardTokenPayload = {
  __typename?: 'DeleteDelegatedWireGuardTokenPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  token: Scalars['String']['output']
}

/** Autogenerated input type of DeleteDeploymentSource */
export type DeleteDeploymentSourceInput = {
  /** The application to update */
  appId: Scalars['String']['input']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
}

/** Autogenerated return type of DeleteDeploymentSource. */
export type DeleteDeploymentSourcePayload = {
  __typename?: 'DeleteDeploymentSourcePayload'
  app?: Maybe<App>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
}

/** Autogenerated input type of DeleteDomain */
export type DeleteDomainInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The node ID of the domain */
  domainId: Scalars['ID']['input']
}

/** Autogenerated return type of DeleteDomain. */
export type DeleteDomainPayload = {
  __typename?: 'DeleteDomainPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  organization: Organization
}

/** Autogenerated input type of DeleteHealthCheckHandler */
export type DeleteHealthCheckHandlerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** Handler name */
  name: Scalars['String']['input']
  /** The node ID of the organization */
  organizationId: Scalars['ID']['input']
}

/** Autogenerated return type of DeleteHealthCheckHandler. */
export type DeleteHealthCheckHandlerPayload = {
  __typename?: 'DeleteHealthCheckHandlerPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
}

/** Autogenerated input type of DeleteLimitedAccessToken */
export type DeleteLimitedAccessTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The node ID for real */
  id?: InputMaybe<Scalars['ID']['input']>
  /** The root of the macaroon */
  token?: InputMaybe<Scalars['String']['input']>
}

/** Autogenerated return type of DeleteLimitedAccessToken. */
export type DeleteLimitedAccessTokenPayload = {
  __typename?: 'DeleteLimitedAccessTokenPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  token?: Maybe<Scalars['String']['output']>
}

/** Autogenerated input type of DeleteOrganization */
export type DeleteOrganizationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The ID of the organization to delete */
  organizationId: Scalars['ID']['input']
}

/** Autogenerated input type of DeleteOrganizationInvitation */
export type DeleteOrganizationInvitationInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The node ID of the invitation */
  invitationId: Scalars['ID']['input']
}

/** Autogenerated return type of DeleteOrganizationInvitation. */
export type DeleteOrganizationInvitationPayload = {
  __typename?: 'DeleteOrganizationInvitationPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  organization: Organization
}

/** Autogenerated input type of DeleteOrganizationMembership */
export type DeleteOrganizationMembershipInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The node ID of the organization */
  organizationId: Scalars['ID']['input']
  /** The node ID of the user */
  userId: Scalars['ID']['input']
}

/** Autogenerated return type of DeleteOrganizationMembership. */
export type DeleteOrganizationMembershipPayload = {
  __typename?: 'DeleteOrganizationMembershipPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  organization: Organization
  user: User
}

/** Autogenerated return type of DeleteOrganization. */
export type DeleteOrganizationPayload = {
  __typename?: 'DeleteOrganizationPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  deletedOrganizationId: Scalars['ID']['output']
}

/** Autogenerated input type of DeleteRemoteBuilder */
export type DeleteRemoteBuilderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The node ID of the organization */
  organizationId: Scalars['ID']['input']
}

/** Autogenerated return type of DeleteRemoteBuilder. */
export type DeleteRemoteBuilderPayload = {
  __typename?: 'DeleteRemoteBuilderPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  organization: Organization
}

/** Autogenerated input type of DeleteVolume */
export type DeleteVolumeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** Unique lock ID */
  lockId?: InputMaybe<Scalars['ID']['input']>
  /** The node ID of the volume */
  volumeId: Scalars['ID']['input']
}

/** Autogenerated return type of DeleteVolume. */
export type DeleteVolumePayload = {
  __typename?: 'DeleteVolumePayload'
  app: App
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
}

/** Autogenerated input type of DeployImage */
export type DeployImageInput = {
  /** The ID of the app */
  appId: Scalars['ID']['input']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** app definition */
  definition?: InputMaybe<Scalars['JSON']['input']>
  /** The image to deploy */
  image: Scalars['String']['input']
  /** Network services to expose */
  services?: InputMaybe<Array<ServiceInput>>
  /** The strategy for replacing existing instances. Defaults to canary. */
  strategy?: InputMaybe<DeploymentStrategy>
}

/** Autogenerated return type of DeployImage. */
export type DeployImagePayload = {
  __typename?: 'DeployImagePayload'
  app: App
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  release?: Maybe<Release>
  releaseCommand?: Maybe<ReleaseCommand>
}

/** Continuous deployment configuration */
export type DeploymentSource = {
  __typename?: 'DeploymentSource'
  backend: Scalars['JSON']['output']
  baseDir: Scalars['String']['output']
  connected: Scalars['Boolean']['output']
  id: Scalars['ID']['output']
  provider: Scalars['String']['output']
  /** The ref to build from */
  ref: Scalars['String']['output']
  repositoryId: Scalars['String']['output']
  /** The repository to fetch source code from */
  repositoryUrl: Scalars['String']['output']
}

export type DeploymentStatus = {
  __typename?: 'DeploymentStatus'
  allocations: Array<Allocation>
  description: Scalars['String']['output']
  desiredCount: Scalars['Int']['output']
  healthyCount: Scalars['Int']['output']
  /** Unique ID for this deployment */
  id: Scalars['ID']['output']
  inProgress: Scalars['Boolean']['output']
  placedCount: Scalars['Int']['output']
  promoted: Scalars['Boolean']['output']
  status: Scalars['String']['output']
  successful: Scalars['Boolean']['output']
  unhealthyCount: Scalars['Int']['output']
  version: Scalars['Int']['output']
}

export enum DeploymentStrategy {
  /** Launch all new instances before shutting down previous instances */
  Bluegreen = 'BLUEGREEN',
  /** Ensure new instances are healthy before continuing with a rolling deployment */
  Canary = 'CANARY',
  /** Deploy new instances all at once */
  Immediate = 'IMMEDIATE',
  /** Incrementally replace old instances with new ones */
  Rolling = 'ROLLING',
  /** Incrementally replace old instances with new ones, 1 by 1 */
  RollingOne = 'ROLLING_ONE',
  /** Deploy new instances all at once */
  Simple = 'SIMPLE'
}

/** Autogenerated input type of DetachPostgresCluster */
export type DetachPostgresClusterInput = {
  /** The application to detach postgres from */
  appId: Scalars['ID']['input']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The postgres cluster application id */
  postgresClusterAppId: Scalars['ID']['input']
  /** The postgres attachment id */
  postgresClusterAttachmentId?: InputMaybe<Scalars['ID']['input']>
}

/** Autogenerated return type of DetachPostgresCluster. */
export type DetachPostgresClusterPayload = {
  __typename?: 'DetachPostgresClusterPayload'
  app: App
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  postgresClusterApp: App
}

/** Autogenerated input type of DischargeRootToken */
export type DischargeRootTokenInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  expiry?: InputMaybe<Scalars['String']['input']>
  organizationId: Scalars['Int']['input']
  rootToken: Scalars['String']['input']
}

/** Autogenerated return type of DischargeRootToken. */
export type DischargeRootTokenPayload = {
  __typename?: 'DischargeRootTokenPayload'
  authToken: Scalars['String']['output']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
}

export type Domain = Node & {
  __typename?: 'Domain'
  autoRenew?: Maybe<Scalars['Boolean']['output']>
  createdAt: Scalars['ISO8601DateTime']['output']
  /** The delegated nameservers for the registration */
  delegatedNameservers?: Maybe<Array<Scalars['String']['output']>>
  /** The dns records for this domain */
  dnsRecords: DnsRecordConnection
  dnsStatus: DomainDnsStatus
  expiresAt?: Maybe<Scalars['ISO8601DateTime']['output']>
  id: Scalars['ID']['output']
  /** The name for this domain */
  name: Scalars['String']['output']
  /** The organization that owns this domain */
  organization: Organization
  registrationStatus: DomainRegistrationStatus
  updatedAt: Scalars['ISO8601DateTime']['output']
  /** The nameservers for the hosted zone */
  zoneNameservers: Array<Scalars['String']['output']>
}

export type DomainDnsRecordsArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

/** The connection type for Domain. */
export type DomainConnection = {
  __typename?: 'DomainConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DomainEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Domain>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

export enum DomainDnsStatus {
  /** The DNS zone has not been created yet */
  Pending = 'PENDING',
  /** The DNS zone is ready */
  Ready = 'READY',
  /** The DNS zone is being updated */
  Updating = 'UPDATING'
}

/** An edge in a connection. */
export type DomainEdge = {
  __typename?: 'DomainEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output']
  /** The item at the end of the edge. */
  node?: Maybe<Domain>
}

export enum DomainRegistrationStatus {
  /** The domain registration has expired */
  Expired = 'EXPIRED',
  /** The domain is registered */
  Registered = 'REGISTERED',
  /** The domain is being registered */
  Registering = 'REGISTERING',
  /** The domain is being transferred */
  Transferring = 'TRANSFERRING',
  /** The domain is not registered on fly */
  Unmanaged = 'UNMANAGED'
}

/** Autogenerated input type of DummyWireGuardPeer */
export type DummyWireGuardPeerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The node ID of the organization */
  organizationId: Scalars['ID']['input']
  /** The region in which to deploy the peer */
  region?: InputMaybe<Scalars['String']['input']>
}

/** Autogenerated return type of DummyWireGuardPeer. */
export type DummyWireGuardPeerPayload = {
  __typename?: 'DummyWireGuardPeerPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  endpointip: Scalars['String']['output']
  localpub: Scalars['String']['output']
  peerip: Scalars['String']['output']
  privkey: Scalars['String']['output']
  pubkey: Scalars['String']['output']
}

export type EmptyAppRole = AppRole & {
  __typename?: 'EmptyAppRole'
  /** The name of this role */
  name: Scalars['String']['output']
}

/** Autogenerated input type of EnablePostgresConsul */
export type EnablePostgresConsulInput = {
  /** The ID of the app */
  appId?: InputMaybe<Scalars['ID']['input']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
}

/** Autogenerated return type of EnablePostgresConsul. */
export type EnablePostgresConsulPayload = {
  __typename?: 'EnablePostgresConsulPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  consulUrl: Scalars['String']['output']
}

/** Autogenerated input type of EnsureMachineRemoteBuilder */
export type EnsureMachineRemoteBuilderInput = {
  /** The unique application name */
  appName?: InputMaybe<Scalars['String']['input']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The node ID of the organization */
  organizationId?: InputMaybe<Scalars['ID']['input']>
  /** Desired region for the remote builder */
  region?: InputMaybe<Scalars['String']['input']>
  /** Use v2 machines */
  v2?: InputMaybe<Scalars['Boolean']['input']>
}

/** Autogenerated return type of EnsureMachineRemoteBuilder. */
export type EnsureMachineRemoteBuilderPayload = {
  __typename?: 'EnsureMachineRemoteBuilderPayload'
  app: App
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  machine: Machine
}

/** Autogenerated input type of EstablishSSHKey */
export type EstablishSshKeyInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The node ID of the organization */
  organizationId: Scalars['ID']['input']
  /** Establish a key even if one is already set */
  override?: InputMaybe<Scalars['Boolean']['input']>
}

/** Autogenerated return type of EstablishSSHKey. */
export type EstablishSshKeyPayload = {
  __typename?: 'EstablishSSHKeyPayload'
  certificate: Scalars['String']['output']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
}

/** Autogenerated input type of ExportDNSZone */
export type ExportDnsZoneInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** ID of the domain to export */
  domainId: Scalars['ID']['input']
}

/** Autogenerated return type of ExportDNSZone. */
export type ExportDnsZonePayload = {
  __typename?: 'ExportDNSZonePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  contents: Scalars['String']['output']
  domain: Domain
}

/** Autogenerated input type of ExtendVolume */
export type ExtendVolumeInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The target volume size */
  sizeGb: Scalars['Int']['input']
  /** The node ID of the volume */
  volumeId: Scalars['ID']['input']
}

/** Autogenerated return type of ExtendVolume. */
export type ExtendVolumePayload = {
  __typename?: 'ExtendVolumePayload'
  app: App
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  needsRestart: Scalars['Boolean']['output']
  volume: Volume
}

/** Autogenerated input type of FinishBuild */
export type FinishBuildInput = {
  /** The name of the app being built */
  appName: Scalars['ID']['input']
  /** Build id returned by createBuild() mutation */
  buildId: Scalars['ID']['input']
  /** Metadata about the builder */
  builderMeta?: InputMaybe<BuilderMetaInput>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** Information about the docker image that was built */
  finalImage?: InputMaybe<BuildFinalImageInput>
  /** Log or error output */
  logs?: InputMaybe<Scalars['String']['input']>
  /** The ID of the machine being built (only set for machine builds) */
  machineId?: InputMaybe<Scalars['ID']['input']>
  /** Indicate whether build completed or failed */
  status: Scalars['String']['input']
  /** Build strategies attempted and their result, should be in order of attempt */
  strategiesAttempted?: InputMaybe<Array<BuildStrategyAttemptInput>>
  /** Timings for different phases of the build */
  timings?: InputMaybe<BuildTimingsInput>
}

/** Autogenerated return type of FinishBuild. */
export type FinishBuildPayload = {
  __typename?: 'FinishBuildPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  /** build id */
  id: Scalars['ID']['output']
  /** stored build status */
  status: Scalars['String']['output']
  /** wall clock time for this build */
  wallclockTimeMs: Scalars['Int']['output']
}

export type FlyPlatform = {
  __typename?: 'FlyPlatform'
  /** Latest flyctl release details */
  flyctl: FlyctlRelease
  /** Fly global regions */
  regions: Array<Region>
  /** Region current request from */
  requestRegion?: Maybe<Scalars['String']['output']>
  /** Available VM sizes */
  vmSizes: Array<VmSize>
}

export type FlyctlMachineHostAppRole = AppRole & {
  __typename?: 'FlyctlMachineHostAppRole'
  /** The name of this role */
  name: Scalars['String']['output']
}

export type FlyctlRelease = {
  __typename?: 'FlyctlRelease'
  timestamp: Scalars['ISO8601DateTime']['output']
  version: Scalars['String']['output']
}

/** Autogenerated input type of ForkVolume */
export type ForkVolumeInput = {
  /** The application to attach the new volume to */
  appId: Scalars['ID']['input']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** Unique lock ID */
  lockId?: InputMaybe<Scalars['ID']['input']>
  /** Lock the new volume to only usable on machines */
  machinesOnly?: InputMaybe<Scalars['Boolean']['input']>
  /** Volume name */
  name?: InputMaybe<Scalars['String']['input']>
  /** Enables experimental cross-host volume forking */
  remote?: InputMaybe<Scalars['Boolean']['input']>
  /** The volume to fork */
  sourceVolId: Scalars['ID']['input']
}

/** Autogenerated return type of ForkVolume. */
export type ForkVolumePayload = {
  __typename?: 'ForkVolumePayload'
  app: App
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  volume: Volume
}

export enum FsTypeType {
  /** default ext4 filesystem */
  Ext4 = 'ext4',
  /** raw block device, no filesystem */
  Raw = 'raw'
}

export type GithubAppInstallation = {
  __typename?: 'GithubAppInstallation'
  editUrl: Scalars['String']['output']
  id: Scalars['ID']['output']
  owner: Scalars['String']['output']
  repositories: Array<GithubRepository>
}

export type GithubIntegration = {
  __typename?: 'GithubIntegration'
  installationUrl: Scalars['String']['output']
  installations: Array<GithubAppInstallation>
  viewerAuthenticated: Scalars['Boolean']['output']
}

export type GithubRepository = {
  __typename?: 'GithubRepository'
  fork: Scalars['Boolean']['output']
  fullName: Scalars['String']['output']
  id: Scalars['String']['output']
  name: Scalars['String']['output']
  private: Scalars['Boolean']['output']
}

/** Autogenerated input type of GrantPostgresClusterUserAccess */
export type GrantPostgresClusterUserAccessInput = {
  /** The name of the postgres cluster app */
  appName: Scalars['String']['input']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The database to grant access to */
  databaseName: Scalars['String']['input']
  /** The name of the database */
  username: Scalars['String']['input']
}

/** Autogenerated return type of GrantPostgresClusterUserAccess. */
export type GrantPostgresClusterUserAccessPayload = {
  __typename?: 'GrantPostgresClusterUserAccessPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  database: PostgresClusterDatabase
  postgresClusterRole: PostgresClusterAppRole
  user: PostgresClusterUser
}

export enum HttpMethod {
  Delete = 'DELETE',
  Get = 'GET',
  Head = 'HEAD',
  Patch = 'PATCH',
  Post = 'POST',
  Put = 'PUT'
}

export enum HttpProtocol {
  /** HTTP protocol */
  Http = 'HTTP',
  /** HTTPS protocol */
  Https = 'HTTPS'
}

export type HealthCheck = {
  __typename?: 'HealthCheck'
  /** Raw name of entity */
  entity: Scalars['String']['output']
  /** Time check last passed */
  lastPassing?: Maybe<Scalars['ISO8601DateTime']['output']>
  /** Check name */
  name: Scalars['String']['output']
  /** Latest check output */
  output?: Maybe<Scalars['String']['output']>
  /** Current check state */
  state: Scalars['String']['output']
}

/** The connection type for HealthCheck. */
export type HealthCheckConnection = {
  __typename?: 'HealthCheckConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<HealthCheckEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<HealthCheck>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/** An edge in a connection. */
export type HealthCheckEdge = {
  __typename?: 'HealthCheckEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output']
  /** The item at the end of the edge. */
  node?: Maybe<HealthCheck>
}

export type HealthCheckHandler = {
  __typename?: 'HealthCheckHandler'
  /** Handler name */
  name: Scalars['String']['output']
  /** Handler type (Slack or Pagerduty) */
  type: Scalars['String']['output']
}

/** The connection type for HealthCheckHandler. */
export type HealthCheckHandlerConnection = {
  __typename?: 'HealthCheckHandlerConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<HealthCheckHandlerEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<HealthCheckHandler>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/** An edge in a connection. */
export type HealthCheckHandlerEdge = {
  __typename?: 'HealthCheckHandlerEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output']
  /** The item at the end of the edge. */
  node?: Maybe<HealthCheckHandler>
}

export type HerokuApp = {
  __typename?: 'HerokuApp'
  id: Scalars['String']['output']
  name: Scalars['String']['output']
  region?: Maybe<Scalars['String']['output']>
  releasedAt: Scalars['ISO8601DateTime']['output']
  stack?: Maybe<Scalars['String']['output']>
  teamName?: Maybe<Scalars['String']['output']>
}

export type HerokuIntegration = {
  __typename?: 'HerokuIntegration'
  herokuApps: Array<HerokuApp>
  viewerAuthenticated: Scalars['Boolean']['output']
}

export type Host = Node & {
  __typename?: 'Host'
  id: Scalars['ID']['output']
}

export type HostnameCheck = {
  __typename?: 'HostnameCheck'
  aRecords: Array<Scalars['String']['output']>
  aaaaRecords: Array<Scalars['String']['output']>
  acmeDnsConfigured: Scalars['Boolean']['output']
  caaRecords: Array<Scalars['String']['output']>
  cnameRecords: Array<Scalars['String']['output']>
  dnsConfigured: Scalars['Boolean']['output']
  dnsProvider?: Maybe<Scalars['String']['output']>
  dnsVerificationRecord?: Maybe<Scalars['String']['output']>
  errors?: Maybe<Array<Scalars['String']['output']>>
  id: Scalars['ID']['output']
  isProxied: Scalars['Boolean']['output']
  resolvedAddresses: Array<Scalars['String']['output']>
  soa?: Maybe<Scalars['String']['output']>
}

export type IpAddress = Node & {
  __typename?: 'IPAddress'
  address: Scalars['String']['output']
  createdAt: Scalars['ISO8601DateTime']['output']
  id: Scalars['ID']['output']
  region?: Maybe<Scalars['String']['output']>
  type: IpAddressType
}

/** The connection type for IPAddress. */
export type IpAddressConnection = {
  __typename?: 'IPAddressConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<IpAddressEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<IpAddress>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/** An edge in a connection. */
export type IpAddressEdge = {
  __typename?: 'IPAddressEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output']
  /** The item at the end of the edge. */
  node?: Maybe<IpAddress>
}

export enum IpAddressType {
  PrivateV6 = 'private_v6',
  SharedV4 = 'shared_v4',
  V4 = 'v4',
  V6 = 'v6'
}

export type Image = {
  __typename?: 'Image'
  absoluteRef: Scalars['String']['output']
  /** @deprecated Int cannot handle sizes over 2GB. Use compressed_size_full instead */
  compressedSize: Scalars['Int']['output']
  compressedSizeFull: Scalars['BigInt']['output']
  config: Scalars['JSON']['output']
  configDigest: Scalars['JSON']['output']
  createdAt: Scalars['ISO8601DateTime']['output']
  digest: Scalars['String']['output']
  id: Scalars['ID']['output']
  label: Scalars['String']['output']
  manifest: Scalars['JSON']['output']
  ref: Scalars['String']['output']
  registry: Scalars['String']['output']
  repository: Scalars['String']['output']
  tag?: Maybe<Scalars['String']['output']>
}

export type ImageVersion = {
  __typename?: 'ImageVersion'
  digest: Scalars['String']['output']
  registry: Scalars['String']['output']
  repository: Scalars['String']['output']
  tag: Scalars['String']['output']
  version?: Maybe<Scalars['String']['output']>
}

/** Autogenerated return type of ImportCertificate. */
export type ImportCertificatePayload = {
  __typename?: 'ImportCertificatePayload'
  app?: Maybe<App>
  appCertificate?: Maybe<AppCertificate>
  certificate?: Maybe<Certificate>
  errors?: Maybe<Array<Scalars['String']['output']>>
}

/** Autogenerated input type of ImportDNSZone */
export type ImportDnsZoneInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** ID of the domain to export */
  domainId: Scalars['ID']['input']
  zonefile: Scalars['String']['input']
}

/** Autogenerated return type of ImportDNSZone. */
export type ImportDnsZonePayload = {
  __typename?: 'ImportDNSZonePayload'
  changes: Array<DnsRecordDiff>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  domain: Domain
  warnings: Array<DnsRecordWarning>
}

/** Autogenerated input type of IssueCertificate */
export type IssueCertificateInput = {
  /** The names of the apps this certificate will be limited to accessing */
  appNames?: InputMaybe<Array<Scalars['String']['input']>>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The node ID of the organization */
  organizationId: Scalars['ID']['input']
  /** SSH principals for certificate (e.g. ["fly", "root"]) */
  principals?: InputMaybe<Array<Scalars['String']['input']>>
  /** The openssh-formatted ED25519 public key to issue the certificate for */
  publicKey?: InputMaybe<Scalars['String']['input']>
  /** Hours for which certificate will be valid */
  validHours?: InputMaybe<Scalars['Int']['input']>
}

/** Autogenerated return type of IssueCertificate. */
export type IssueCertificatePayload = {
  __typename?: 'IssueCertificatePayload'
  certificate: Scalars['String']['output']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  /**
   * The private key, if a public_key wasn't specified
   * @deprecated Specify your own public key
   */
  key?: Maybe<Scalars['String']['output']>
}

/** Autogenerated input type of KillMachine */
export type KillMachineInput = {
  /** The ID of the app */
  appId?: InputMaybe<Scalars['ID']['input']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** machine id */
  id: Scalars['String']['input']
}

/** Autogenerated return type of KillMachine. */
export type KillMachinePayload = {
  __typename?: 'KillMachinePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  machine: Machine
}

/** Autogenerated input type of LaunchApp */
export type LaunchAppInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** Configuration */
  config?: InputMaybe<Scalars['JSON']['input']>
  /** Number of instances to run */
  count?: InputMaybe<Scalars['Int']['input']>
  /** Docker image to launch */
  image: Scalars['String']['input']
  /** App name to create */
  name?: InputMaybe<Scalars['String']['input']>
  /** The node ID of the organization */
  organizationId: Scalars['ID']['input']
  /** Regions to launch your app to */
  regions?: InputMaybe<Array<Scalars['String']['input']>>
  /** Type of scheduling for this app */
  scheduling?: InputMaybe<SchedulingEnum>
  /** Secrets to set */
  secrets?: InputMaybe<Array<SecretInput>>
  /** Size of VM for your app */
  vmSize?: InputMaybe<VmSizeEnum>
  /** Volumes to create */
  volumes?: InputMaybe<Array<VolumeInput>>
}

/** Autogenerated return type of LaunchApp. */
export type LaunchAppPayload = {
  __typename?: 'LaunchAppPayload'
  app: App
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  release?: Maybe<Release>
}

/** Autogenerated input type of LaunchMachine */
export type LaunchMachineInput = {
  /** The ID of the app */
  appId?: InputMaybe<Scalars['ID']['input']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** Configuration */
  config: Scalars['JSON']['input']
  /** The ID of the machine */
  id?: InputMaybe<Scalars['String']['input']>
  /** The name of the machine */
  name?: InputMaybe<Scalars['String']['input']>
  /** The node ID of the organization */
  organizationId?: InputMaybe<Scalars['ID']['input']>
  /** Region for the machine */
  region?: InputMaybe<Scalars['String']['input']>
}

/** Autogenerated return type of LaunchMachine. */
export type LaunchMachinePayload = {
  __typename?: 'LaunchMachinePayload'
  app: App
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  machine: Machine
}

export type LimitedAccessToken = Node & {
  __typename?: 'LimitedAccessToken'
  createdAt: Scalars['ISO8601DateTime']['output']
  expiresAt: Scalars['ISO8601DateTime']['output']
  id: Scalars['ID']['output']
  name: Scalars['String']['output']
  token: Scalars['String']['output']
  tokenHeader?: Maybe<Scalars['String']['output']>
}

/** The connection type for LimitedAccessToken. */
export type LimitedAccessTokenConnection = {
  __typename?: 'LimitedAccessTokenConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LimitedAccessTokenEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<LimitedAccessToken>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/** An edge in a connection. */
export type LimitedAccessTokenEdge = {
  __typename?: 'LimitedAccessTokenEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output']
  /** The item at the end of the edge. */
  node?: Maybe<LimitedAccessToken>
}

/** Autogenerated input type of LockApp */
export type LockAppInput = {
  /** The ID of the app */
  appId: Scalars['ID']['input']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
}

/** Autogenerated return type of LockApp. */
export type LockAppPayload = {
  __typename?: 'LockAppPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  /** When this lock automatically expires */
  expiration?: Maybe<Scalars['ISO8601DateTime']['output']>
  /** Unique lock ID */
  lockId?: Maybe<Scalars['ID']['output']>
}

export type LogEntry = {
  __typename?: 'LogEntry'
  id: Scalars['String']['output']
  instanceId: Scalars['String']['output']
  level: Scalars['String']['output']
  message: Scalars['String']['output']
  region: Scalars['String']['output']
  timestamp: Scalars['ISO8601DateTime']['output']
}

/** Autogenerated input type of LogOut */
export type LogOutInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
}

/** Autogenerated return type of LogOut. */
export type LogOutPayload = {
  __typename?: 'LogOutPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  ok: Scalars['Boolean']['output']
}

export type LoggedCertificate = Node & {
  __typename?: 'LoggedCertificate'
  cert: Scalars['String']['output']
  id: Scalars['ID']['output']
  root: Scalars['Boolean']['output']
}

/** The connection type for LoggedCertificate. */
export type LoggedCertificateConnection = {
  __typename?: 'LoggedCertificateConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LoggedCertificateEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<LoggedCertificate>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/** An edge in a connection. */
export type LoggedCertificateEdge = {
  __typename?: 'LoggedCertificateEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output']
  /** The item at the end of the edge. */
  node?: Maybe<LoggedCertificate>
}

export type Macaroon = Principal & {
  __typename?: 'Macaroon'
  /** URL for avatar or placeholder */
  avatarUrl: Scalars['String']['output']
  /** @deprecated Use User fragment on Viewer instead */
  createdAt?: Maybe<Scalars['ISO8601DateTime']['output']>
  /** Email address for principal */
  email: Scalars['String']['output']
  /** @deprecated Use User fragment on Viewer instead */
  featureFlags?: Maybe<Array<Scalars['String']['output']>>
  /** @deprecated Use User fragment on Viewer instead */
  hasNodeproxyApps?: Maybe<Scalars['Boolean']['output']>
  /** @deprecated Use User fragment on Viewer instead */
  id?: Maybe<Scalars['ID']['output']>
  /** @deprecated Use User fragment on Viewer instead */
  lastRegion?: Maybe<Scalars['String']['output']>
  /** Display name of principal */
  name?: Maybe<Scalars['String']['output']>
  /** @deprecated Use User fragment on Viewer instead */
  organizations?: Maybe<OrganizationConnection>
  /** @deprecated Use User fragment on Viewer instead */
  personalOrganization?: Maybe<Organization>
  trust: OrganizationTrust
  /** @deprecated Use User fragment on Viewer instead */
  twoFactorProtection?: Maybe<Scalars['Boolean']['output']>
  /** @deprecated Use User fragment on Viewer instead */
  username?: Maybe<Scalars['String']['output']>
}

export type MacaroonOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

export type Machine = Node & {
  __typename?: 'Machine'
  app: App
  config: Scalars['JSON']['output']
  createdAt: Scalars['ISO8601DateTime']['output']
  events: MachineEventConnection
  host: Host
  id: Scalars['ID']['output']
  instanceId: Scalars['String']['output']
  ips: MachineIpConnection
  name: Scalars['String']['output']
  region: Scalars['String']['output']
  state: Scalars['String']['output']
  updatedAt: Scalars['ISO8601DateTime']['output']
}

export type MachineEventsArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  kind?: InputMaybe<Scalars['String']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

export type MachineIpsArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

/** The connection type for Machine. */
export type MachineConnection = {
  __typename?: 'MachineConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MachineEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Machine>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/** An edge in a connection. */
export type MachineEdge = {
  __typename?: 'MachineEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output']
  /** The item at the end of the edge. */
  node?: Maybe<Machine>
}

/** A machine state change event */
export type MachineEvent = {
  id: Scalars['ID']['output']
  kind: Scalars['String']['output']
  timestamp: Scalars['ISO8601DateTime']['output']
}

/** The connection type for MachineEvent. */
export type MachineEventConnection = {
  __typename?: 'MachineEventConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MachineEventEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MachineEvent>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
}

export type MachineEventDestroy = MachineEvent & {
  __typename?: 'MachineEventDestroy'
  id: Scalars['ID']['output']
  kind: Scalars['String']['output']
  timestamp: Scalars['ISO8601DateTime']['output']
}

/** An edge in a connection. */
export type MachineEventEdge = {
  __typename?: 'MachineEventEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output']
  /** The item at the end of the edge. */
  node?: Maybe<MachineEvent>
}

export type MachineEventExit = MachineEvent & {
  __typename?: 'MachineEventExit'
  exitCode: Scalars['Int']['output']
  id: Scalars['ID']['output']
  kind: Scalars['String']['output']
  metadata: Scalars['JSON']['output']
  oomKilled: Scalars['Boolean']['output']
  requestedStop: Scalars['Boolean']['output']
  timestamp: Scalars['ISO8601DateTime']['output']
}

export type MachineEventGeneric = MachineEvent & {
  __typename?: 'MachineEventGeneric'
  id: Scalars['ID']['output']
  kind: Scalars['String']['output']
  timestamp: Scalars['ISO8601DateTime']['output']
}

export type MachineEventStart = MachineEvent & {
  __typename?: 'MachineEventStart'
  id: Scalars['ID']['output']
  kind: Scalars['String']['output']
  timestamp: Scalars['ISO8601DateTime']['output']
}

export type MachineIp = Node & {
  __typename?: 'MachineIP'
  family: Scalars['String']['output']
  /** ID of the object. */
  id: Scalars['ID']['output']
  ip: Scalars['String']['output']
  kind: Scalars['String']['output']
  maskSize: Scalars['Int']['output']
}

/** The connection type for MachineIP. */
export type MachineIpConnection = {
  __typename?: 'MachineIPConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<MachineIpEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<MachineIp>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/** An edge in a connection. */
export type MachineIpEdge = {
  __typename?: 'MachineIPEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output']
  /** The item at the end of the edge. */
  node?: Maybe<MachineIp>
}

/** Autogenerated input type of MoveApp */
export type MoveAppInput = {
  /** The application to move */
  appId: Scalars['ID']['input']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The node ID of the organization to move the app to */
  organizationId: Scalars['ID']['input']
}

/** Autogenerated return type of MoveApp. */
export type MoveAppPayload = {
  __typename?: 'MoveAppPayload'
  app: App
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
}

export type Mutations = {
  __typename?: 'Mutations'
  addCertificate?: Maybe<AddCertificatePayload>
  addWireGuardPeer?: Maybe<AddWireGuardPeerPayload>
  allocateIpAddress?: Maybe<AllocateIpAddressPayload>
  attachPostgresCluster?: Maybe<AttachPostgresClusterPayload>
  cancelBuild?: Maybe<CancelBuildPayload>
  checkCertificate?: Maybe<CheckCertificatePayload>
  checkDomain?: Maybe<CheckDomainPayload>
  configureRegions?: Maybe<ConfigureRegionsPayload>
  createAddOn?: Maybe<CreateAddOnPayload>
  createAndRegisterDomain?: Maybe<CreateAndRegisterDomainPayload>
  createAndTransferDomain?: Maybe<CreateAndTransferDomainPayload>
  createApp?: Maybe<CreateAppPayload>
  createBuild?: Maybe<CreateBuildPayload>
  createCheckJob?: Maybe<CreateCheckJobPayload>
  createCheckJobRun?: Maybe<CreateCheckJobRunPayload>
  createDelegatedWireGuardToken?: Maybe<CreateDelegatedWireGuardTokenPayload>
  createDnsPortal?: Maybe<CreateDnsPortalPayload>
  createDnsPortalSession?: Maybe<CreateDnsPortalSessionPayload>
  createDnsRecord?: Maybe<CreateDnsRecordPayload>
  createDoctorReport?: Maybe<CreateDoctorReportPayload>
  createDoctorUrl?: Maybe<CreateDoctorUrlPayload>
  createDomain?: Maybe<CreateDomainPayload>
  createExtensionTosAgreement?: Maybe<CreateExtensionTosAgreementPayload>
  createLimitedAccessToken?: Maybe<CreateLimitedAccessTokenPayload>
  createOrganization?: Maybe<CreateOrganizationPayload>
  createOrganizationInvitation?: Maybe<CreateOrganizationInvitationPayload>
  createPostgresCluster?: Maybe<CreatePostgresClusterPayload>
  createPostgresClusterDatabase?: Maybe<CreatePostgresClusterDatabasePayload>
  createPostgresClusterUser?: Maybe<CreatePostgresClusterUserPayload>
  createRelease?: Maybe<CreateReleasePayload>
  createTemplateDeployment?: Maybe<CreateTemplateDeploymentPayload>
  createVolume?: Maybe<CreateVolumePayload>
  createVolumeSnapshot?: Maybe<CreateVolumeSnapshotPayload>
  deleteAddOn?: Maybe<DeleteAddOnPayload>
  /** Delete an app */
  deleteApp?: Maybe<DeleteAppPayload>
  deleteCertificate?: Maybe<DeleteCertificatePayload>
  deleteDelegatedWireGuardToken?: Maybe<DeleteDelegatedWireGuardTokenPayload>
  deleteDeploymentSource?: Maybe<DeleteDeploymentSourcePayload>
  deleteDnsPortal?: Maybe<DeleteDnsPortalPayload>
  deleteDnsPortalSession?: Maybe<DeleteDnsPortalSessionPayload>
  deleteDnsRecord?: Maybe<DeleteDnsRecordPayload>
  deleteDomain?: Maybe<DeleteDomainPayload>
  deleteHealthCheckHandler?: Maybe<DeleteHealthCheckHandlerPayload>
  deleteLimitedAccessToken?: Maybe<DeleteLimitedAccessTokenPayload>
  deleteOrganization?: Maybe<DeleteOrganizationPayload>
  deleteOrganizationInvitation?: Maybe<DeleteOrganizationInvitationPayload>
  deleteOrganizationMembership?: Maybe<DeleteOrganizationMembershipPayload>
  deleteRemoteBuilder?: Maybe<DeleteRemoteBuilderPayload>
  deleteVolume?: Maybe<DeleteVolumePayload>
  deployImage?: Maybe<DeployImagePayload>
  detachPostgresCluster?: Maybe<DetachPostgresClusterPayload>
  dischargeRootToken?: Maybe<DischargeRootTokenPayload>
  dummyWireGuardPeer?: Maybe<DummyWireGuardPeerPayload>
  enablePostgresConsul?: Maybe<EnablePostgresConsulPayload>
  ensureMachineRemoteBuilder?: Maybe<EnsureMachineRemoteBuilderPayload>
  establishSshKey?: Maybe<EstablishSshKeyPayload>
  exportDnsZone?: Maybe<ExportDnsZonePayload>
  extendVolume?: Maybe<ExtendVolumePayload>
  finishBuild?: Maybe<FinishBuildPayload>
  forkVolume?: Maybe<ForkVolumePayload>
  grantPostgresClusterUserAccess?: Maybe<GrantPostgresClusterUserAccessPayload>
  importCertificate?: Maybe<ImportCertificatePayload>
  importDnsZone?: Maybe<ImportDnsZonePayload>
  issueCertificate?: Maybe<IssueCertificatePayload>
  killMachine?: Maybe<KillMachinePayload>
  launchApp?: Maybe<LaunchAppPayload>
  launchMachine?: Maybe<LaunchMachinePayload>
  lockApp?: Maybe<LockAppPayload>
  logOut?: Maybe<LogOutPayload>
  moveApp?: Maybe<MoveAppPayload>
  nomadToMachinesMigration?: Maybe<NomadToMachinesMigrationPayload>
  nomadToMachinesMigrationPrep?: Maybe<NomadToMachinesMigrationPrepPayload>
  pauseApp?: Maybe<PauseAppPayload>
  registerDomain?: Maybe<RegisterDomainPayload>
  releaseIpAddress?: Maybe<ReleaseIpAddressPayload>
  removeMachine?: Maybe<RemoveMachinePayload>
  removeWireGuardPeer?: Maybe<RemoveWireGuardPeerPayload>
  resetAddOnPassword?: Maybe<ResetAddOnPasswordPayload>
  restartAllocation?: Maybe<RestartAllocationPayload>
  restartApp?: Maybe<RestartAppPayload>
  restoreVolumeSnapshot?: Maybe<RestoreVolumeSnapshotPayload>
  resumeApp?: Maybe<ResumeAppPayload>
  revokePostgresClusterUserAccess?: Maybe<RevokePostgresClusterUserAccessPayload>
  saveDeploymentSource?: Maybe<SaveDeploymentSourcePayload>
  scaleApp?: Maybe<ScaleAppPayload>
  setAppsV2DefaultOn?: Maybe<SetAppsv2DefaultOnPayload>
  setPagerdutyHandler?: Maybe<SetPagerdutyHandlerPayload>
  setPlatformVersion?: Maybe<SetPlatformVersionPayload>
  setSecrets?: Maybe<SetSecretsPayload>
  setSlackHandler?: Maybe<SetSlackHandlerPayload>
  setVmCount?: Maybe<SetVmCountPayload>
  setVmSize?: Maybe<SetVmSizePayload>
  startBuild?: Maybe<StartBuildPayload>
  startMachine?: Maybe<StartMachinePayload>
  stopAllocation?: Maybe<StopAllocationPayload>
  stopMachine?: Maybe<StopMachinePayload>
  unlockApp?: Maybe<UnlockAppPayload>
  unsetSecrets?: Maybe<UnsetSecretsPayload>
  updateAddOn?: Maybe<UpdateAddOnPayload>
  updateAutoscaleConfig?: Maybe<UpdateAutoscaleConfigPayload>
  updateDnsPortal?: Maybe<UpdateDnsPortalPayload>
  updateDnsRecord?: Maybe<UpdateDnsRecordPayload>
  updateDnsRecords?: Maybe<UpdateDnsRecordsPayload>
  updateOrganizationMembership?: Maybe<UpdateOrganizationMembershipPayload>
  updateRelease?: Maybe<UpdateReleasePayload>
  updateRemoteBuilder?: Maybe<UpdateRemoteBuilderPayload>
  validateWireGuardPeers?: Maybe<ValidateWireGuardPeersPayload>
}

export type MutationsAddCertificateArgs = {
  appId: Scalars['ID']['input']
  hostname: Scalars['String']['input']
}

export type MutationsAddWireGuardPeerArgs = {
  input: AddWireGuardPeerInput
}

export type MutationsAllocateIpAddressArgs = {
  input: AllocateIpAddressInput
}

export type MutationsAttachPostgresClusterArgs = {
  input: AttachPostgresClusterInput
}

export type MutationsCancelBuildArgs = {
  buildId: Scalars['ID']['input']
}

export type MutationsCheckCertificateArgs = {
  input: CheckCertificateInput
}

export type MutationsCheckDomainArgs = {
  input: CheckDomainInput
}

export type MutationsConfigureRegionsArgs = {
  input: ConfigureRegionsInput
}

export type MutationsCreateAddOnArgs = {
  input: CreateAddOnInput
}

export type MutationsCreateAndRegisterDomainArgs = {
  input: CreateAndRegisterDomainInput
}

export type MutationsCreateAndTransferDomainArgs = {
  input: CreateAndTransferDomainInput
}

export type MutationsCreateAppArgs = {
  input: CreateAppInput
}

export type MutationsCreateBuildArgs = {
  input: CreateBuildInput
}

export type MutationsCreateCheckJobArgs = {
  input: CreateCheckJobInput
}

export type MutationsCreateCheckJobRunArgs = {
  input: CreateCheckJobRunInput
}

export type MutationsCreateDelegatedWireGuardTokenArgs = {
  input: CreateDelegatedWireGuardTokenInput
}

export type MutationsCreateDnsPortalArgs = {
  input: CreateDnsPortalInput
}

export type MutationsCreateDnsPortalSessionArgs = {
  input: CreateDnsPortalSessionInput
}

export type MutationsCreateDnsRecordArgs = {
  input: CreateDnsRecordInput
}

export type MutationsCreateDoctorReportArgs = {
  input: CreateDoctorReportInput
}

export type MutationsCreateDomainArgs = {
  input: CreateDomainInput
}

export type MutationsCreateExtensionTosAgreementArgs = {
  input: CreateExtensionTosAgreementInput
}

export type MutationsCreateLimitedAccessTokenArgs = {
  input: CreateLimitedAccessTokenInput
}

export type MutationsCreateOrganizationArgs = {
  input: CreateOrganizationInput
}

export type MutationsCreateOrganizationInvitationArgs = {
  input: CreateOrganizationInvitationInput
}

export type MutationsCreatePostgresClusterArgs = {
  input: CreatePostgresClusterInput
}

export type MutationsCreatePostgresClusterDatabaseArgs = {
  input: CreatePostgresClusterDatabaseInput
}

export type MutationsCreatePostgresClusterUserArgs = {
  input: CreatePostgresClusterUserInput
}

export type MutationsCreateReleaseArgs = {
  input: CreateReleaseInput
}

export type MutationsCreateTemplateDeploymentArgs = {
  input: CreateTemplateDeploymentInput
}

export type MutationsCreateVolumeArgs = {
  input: CreateVolumeInput
}

export type MutationsCreateVolumeSnapshotArgs = {
  input: CreateVolumeSnapshotInput
}

export type MutationsDeleteAddOnArgs = {
  input: DeleteAddOnInput
}

export type MutationsDeleteAppArgs = {
  appId: Scalars['ID']['input']
}

export type MutationsDeleteCertificateArgs = {
  appId: Scalars['ID']['input']
  hostname: Scalars['String']['input']
}

export type MutationsDeleteDelegatedWireGuardTokenArgs = {
  input: DeleteDelegatedWireGuardTokenInput
}

export type MutationsDeleteDeploymentSourceArgs = {
  input: DeleteDeploymentSourceInput
}

export type MutationsDeleteDnsPortalArgs = {
  input: DeleteDnsPortalInput
}

export type MutationsDeleteDnsPortalSessionArgs = {
  input: DeleteDnsPortalSessionInput
}

export type MutationsDeleteDnsRecordArgs = {
  input: DeleteDnsRecordInput
}

export type MutationsDeleteDomainArgs = {
  input: DeleteDomainInput
}

export type MutationsDeleteHealthCheckHandlerArgs = {
  input: DeleteHealthCheckHandlerInput
}

export type MutationsDeleteLimitedAccessTokenArgs = {
  input: DeleteLimitedAccessTokenInput
}

export type MutationsDeleteOrganizationArgs = {
  input: DeleteOrganizationInput
}

export type MutationsDeleteOrganizationInvitationArgs = {
  input: DeleteOrganizationInvitationInput
}

export type MutationsDeleteOrganizationMembershipArgs = {
  input: DeleteOrganizationMembershipInput
}

export type MutationsDeleteRemoteBuilderArgs = {
  input: DeleteRemoteBuilderInput
}

export type MutationsDeleteVolumeArgs = {
  input: DeleteVolumeInput
}

export type MutationsDeployImageArgs = {
  input: DeployImageInput
}

export type MutationsDetachPostgresClusterArgs = {
  input: DetachPostgresClusterInput
}

export type MutationsDischargeRootTokenArgs = {
  input: DischargeRootTokenInput
}

export type MutationsDummyWireGuardPeerArgs = {
  input: DummyWireGuardPeerInput
}

export type MutationsEnablePostgresConsulArgs = {
  input: EnablePostgresConsulInput
}

export type MutationsEnsureMachineRemoteBuilderArgs = {
  input: EnsureMachineRemoteBuilderInput
}

export type MutationsEstablishSshKeyArgs = {
  input: EstablishSshKeyInput
}

export type MutationsExportDnsZoneArgs = {
  input: ExportDnsZoneInput
}

export type MutationsExtendVolumeArgs = {
  input: ExtendVolumeInput
}

export type MutationsFinishBuildArgs = {
  input: FinishBuildInput
}

export type MutationsForkVolumeArgs = {
  input: ForkVolumeInput
}

export type MutationsGrantPostgresClusterUserAccessArgs = {
  input: GrantPostgresClusterUserAccessInput
}

export type MutationsImportCertificateArgs = {
  appId: Scalars['ID']['input']
  fullchain: Scalars['String']['input']
  hostname?: InputMaybe<Scalars['String']['input']>
  privateKey: Scalars['String']['input']
}

export type MutationsImportDnsZoneArgs = {
  input: ImportDnsZoneInput
}

export type MutationsIssueCertificateArgs = {
  input: IssueCertificateInput
}

export type MutationsKillMachineArgs = {
  input: KillMachineInput
}

export type MutationsLaunchAppArgs = {
  input: LaunchAppInput
}

export type MutationsLaunchMachineArgs = {
  input: LaunchMachineInput
}

export type MutationsLockAppArgs = {
  input: LockAppInput
}

export type MutationsLogOutArgs = {
  input: LogOutInput
}

export type MutationsMoveAppArgs = {
  input: MoveAppInput
}

export type MutationsNomadToMachinesMigrationArgs = {
  input: NomadToMachinesMigrationInput
}

export type MutationsNomadToMachinesMigrationPrepArgs = {
  input: NomadToMachinesMigrationPrepInput
}

export type MutationsPauseAppArgs = {
  input: PauseAppInput
}

export type MutationsRegisterDomainArgs = {
  input: RegisterDomainInput
}

export type MutationsReleaseIpAddressArgs = {
  input: ReleaseIpAddressInput
}

export type MutationsRemoveMachineArgs = {
  input: RemoveMachineInput
}

export type MutationsRemoveWireGuardPeerArgs = {
  input: RemoveWireGuardPeerInput
}

export type MutationsResetAddOnPasswordArgs = {
  input: ResetAddOnPasswordInput
}

export type MutationsRestartAllocationArgs = {
  input: RestartAllocationInput
}

export type MutationsRestartAppArgs = {
  input: RestartAppInput
}

export type MutationsRestoreVolumeSnapshotArgs = {
  input: RestoreVolumeSnapshotInput
}

export type MutationsResumeAppArgs = {
  input: ResumeAppInput
}

export type MutationsRevokePostgresClusterUserAccessArgs = {
  input: RevokePostgresClusterUserAccessInput
}

export type MutationsSaveDeploymentSourceArgs = {
  input: SaveDeploymentSourceInput
}

export type MutationsScaleAppArgs = {
  input: ScaleAppInput
}

export type MutationsSetAppsV2DefaultOnArgs = {
  input: SetAppsv2DefaultOnInput
}

export type MutationsSetPagerdutyHandlerArgs = {
  input: SetPagerdutyHandlerInput
}

export type MutationsSetPlatformVersionArgs = {
  input: SetPlatformVersionInput
}

export type MutationsSetSecretsArgs = {
  input: SetSecretsInput
}

export type MutationsSetSlackHandlerArgs = {
  input: SetSlackHandlerInput
}

export type MutationsSetVmCountArgs = {
  input: SetVmCountInput
}

export type MutationsSetVmSizeArgs = {
  input: SetVmSizeInput
}

export type MutationsStartBuildArgs = {
  input: StartBuildInput
}

export type MutationsStartMachineArgs = {
  input: StartMachineInput
}

export type MutationsStopAllocationArgs = {
  input: StopAllocationInput
}

export type MutationsStopMachineArgs = {
  input: StopMachineInput
}

export type MutationsUnlockAppArgs = {
  input: UnlockAppInput
}

export type MutationsUnsetSecretsArgs = {
  input: UnsetSecretsInput
}

export type MutationsUpdateAddOnArgs = {
  input: UpdateAddOnInput
}

export type MutationsUpdateAutoscaleConfigArgs = {
  input: UpdateAutoscaleConfigInput
}

export type MutationsUpdateDnsPortalArgs = {
  input: UpdateDnsPortalInput
}

export type MutationsUpdateDnsRecordArgs = {
  input: UpdateDnsRecordInput
}

export type MutationsUpdateDnsRecordsArgs = {
  input: UpdateDnsRecordsInput
}

export type MutationsUpdateOrganizationMembershipArgs = {
  input: UpdateOrganizationMembershipInput
}

export type MutationsUpdateReleaseArgs = {
  input: UpdateReleaseInput
}

export type MutationsUpdateRemoteBuilderArgs = {
  input: UpdateRemoteBuilderInput
}

export type MutationsValidateWireGuardPeersArgs = {
  input: ValidateWireGuardPeersInput
}

/** An object with an ID. */
export type Node = {
  /** ID of the object. */
  id: Scalars['ID']['output']
}

/** Autogenerated input type of NomadToMachinesMigration */
export type NomadToMachinesMigrationInput = {
  /** The application to move */
  appId: Scalars['ID']['input']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
}

/** Autogenerated return type of NomadToMachinesMigration. */
export type NomadToMachinesMigrationPayload = {
  __typename?: 'NomadToMachinesMigrationPayload'
  app: App
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
}

/** Autogenerated input type of NomadToMachinesMigrationPrep */
export type NomadToMachinesMigrationPrepInput = {
  /** The application to move */
  appId: Scalars['ID']['input']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
}

/** Autogenerated return type of NomadToMachinesMigrationPrep. */
export type NomadToMachinesMigrationPrepPayload = {
  __typename?: 'NomadToMachinesMigrationPrepPayload'
  app: App
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
}

export type Organization = Node & {
  __typename?: 'Organization'
  activeDiscountName?: Maybe<Scalars['String']['output']>
  /** Single sign-on link for the given integration type */
  addOnSsoLink?: Maybe<Scalars['String']['output']>
  /** List third party integrations associated with an organization */
  addOns: AddOnConnection
  /** Check if the organization has agreed to the extension provider terms of service */
  agreedToProviderTos: Scalars['Boolean']['output']
  apps: AppConnection
  billingStatus: BillingStatus
  /** The account credits in cents */
  creditBalance: Scalars['Int']['output']
  /** The formatted account credits */
  creditBalanceFormatted: Scalars['String']['output']
  delegatedWireGuardTokens: DelegatedWireGuardTokenConnection
  /** Find a dns portal by name */
  dnsPortal: DnsPortal
  dnsPortals: DnsPortalConnection
  /** Find a domain by name */
  domain?: Maybe<Domain>
  domains: DomainConnection
  healthCheckHandlers: HealthCheckHandlerConnection
  healthChecks: HealthCheckConnection
  id: Scalars['ID']['output']
  internalNumericId: Scalars['BigInt']['output']
  invitations: OrganizationInvitationConnection
  isCreditCardSaved: Scalars['Boolean']['output']
  limitedAccessTokens: LimitedAccessTokenConnection
  loggedCertificates?: Maybe<LoggedCertificateConnection>
  members: OrganizationMembershipsConnection
  /** Organization name */
  name: Scalars['String']['output']
  paidPlan: Scalars['Boolean']['output']
  /** Whether the organization can provision beta extensions */
  provisionsBetaExtensions: Scalars['Boolean']['output']
  /** Unmodified unique org slug */
  rawSlug: Scalars['String']['output']
  remoteBuilderApp?: Maybe<App>
  remoteBuilderImage: Scalars['String']['output']
  settings?: Maybe<Scalars['JSON']['output']>
  /** Unique organization slug */
  slug: Scalars['String']['output']
  sshCertificate?: Maybe<Scalars['String']['output']>
  trust: OrganizationTrust
  /** The type of organization */
  type: OrganizationType
  /** The current user's role in the org */
  viewerRole: Scalars['String']['output']
  /** Find a peer by name */
  wireGuardPeer: WireGuardPeer
  wireGuardPeers: WireGuardPeerConnection
}

export type OrganizationAddOnsArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
  type?: InputMaybe<AddOnType>
}

export type OrganizationAgreedToProviderTosArgs = {
  providerName: Scalars['String']['input']
}

export type OrganizationAppsArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

export type OrganizationDelegatedWireGuardTokensArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

export type OrganizationDnsPortalArgs = {
  name: Scalars['String']['input']
}

export type OrganizationDnsPortalsArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

export type OrganizationDomainArgs = {
  name: Scalars['String']['input']
}

export type OrganizationDomainsArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

export type OrganizationHealthCheckHandlersArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

export type OrganizationHealthChecksArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

export type OrganizationInvitationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

export type OrganizationLimitedAccessTokensArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

export type OrganizationLoggedCertificatesArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

export type OrganizationMembersArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

export type OrganizationWireGuardPeerArgs = {
  name: Scalars['String']['input']
}

export type OrganizationWireGuardPeersArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

export enum OrganizationAlertsEnabled {
  /** The user has alerts enabled */
  Enabled = 'ENABLED',
  /** The user does not have alerts enabled */
  NotEnabled = 'NOT_ENABLED'
}

/** The connection type for Organization. */
export type OrganizationConnection = {
  __typename?: 'OrganizationConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<OrganizationEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Organization>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/** An edge in a connection. */
export type OrganizationEdge = {
  __typename?: 'OrganizationEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output']
  /** The item at the end of the edge. */
  node?: Maybe<Organization>
}

export type OrganizationInvitation = Node & {
  __typename?: 'OrganizationInvitation'
  createdAt: Scalars['ISO8601DateTime']['output']
  email: Scalars['String']['output']
  id: Scalars['ID']['output']
  /** The user who created the invitation */
  inviter: User
  organization: Organization
  redeemed: Scalars['Boolean']['output']
  redeemedAt?: Maybe<Scalars['ISO8601DateTime']['output']>
}

/** The connection type for OrganizationInvitation. */
export type OrganizationInvitationConnection = {
  __typename?: 'OrganizationInvitationConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<OrganizationInvitationEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<OrganizationInvitation>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/** An edge in a connection. */
export type OrganizationInvitationEdge = {
  __typename?: 'OrganizationInvitationEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output']
  /** The item at the end of the edge. */
  node?: Maybe<OrganizationInvitation>
}

export enum OrganizationMemberRole {
  /** The user is an administrator of the organization */
  Admin = 'ADMIN',
  /** The user is a member of the organization */
  Member = 'MEMBER'
}

/** The connection type for User. */
export type OrganizationMembershipsConnection = {
  __typename?: 'OrganizationMembershipsConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<OrganizationMembershipsEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<User>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/** An edge in a connection. */
export type OrganizationMembershipsEdge = {
  __typename?: 'OrganizationMembershipsEdge'
  /** The alerts settings the user has in this organization */
  alertsEnabled: OrganizationAlertsEnabled
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output']
  /** The date the user joined the organization */
  joinedAt: Scalars['ISO8601DateTime']['output']
  /** The item at the end of the edge. */
  node?: Maybe<User>
  /** The role the user has in this organization */
  role: OrganizationMemberRole
}

export enum OrganizationTrust {
  /** Organization cannot use our services */
  Banned = 'BANNED',
  /** Organization proved that it's safe to use our services */
  High = 'HIGH',
  /** Organization has to prove that is not fraud over time but can use our services */
  Low = 'LOW',
  /** Organization has limited access to our service */
  Restricted = 'RESTRICTED',
  /** We haven't set a trust level yet */
  Unknown = 'UNKNOWN'
}

export enum OrganizationType {
  /** A user's personal organization */
  Personal = 'PERSONAL',
  /** An organization shared between one or more users */
  Shared = 'SHARED'
}

/** Information about pagination in a connection. */
export type PageInfo = {
  __typename?: 'PageInfo'
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['String']['output']>
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean']['output']
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean']['output']
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['String']['output']>
}

/** Autogenerated input type of PauseApp */
export type PauseAppInput = {
  /** The ID of the app */
  appId: Scalars['ID']['input']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
}

/** Autogenerated return type of PauseApp. */
export type PauseAppPayload = {
  __typename?: 'PauseAppPayload'
  app: App
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
}

export enum PlatformVersionEnum {
  /** App in migration between nomad and machines */
  Detached = 'detached',
  /** App with only machines */
  Machines = 'machines',
  /** Nomad managed application */
  Nomad = 'nomad'
}

export type PostgresClusterAppRole = AppRole & {
  __typename?: 'PostgresClusterAppRole'
  databases: Array<PostgresClusterDatabase>
  /** The name of this role */
  name: Scalars['String']['output']
  users: Array<PostgresClusterUser>
}

export type PostgresClusterAttachment = Node & {
  __typename?: 'PostgresClusterAttachment'
  databaseName: Scalars['String']['output']
  databaseUser: Scalars['String']['output']
  environmentVariableName: Scalars['String']['output']
  id: Scalars['ID']['output']
}

/** The connection type for PostgresClusterAttachment. */
export type PostgresClusterAttachmentConnection = {
  __typename?: 'PostgresClusterAttachmentConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PostgresClusterAttachmentEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<PostgresClusterAttachment>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/** An edge in a connection. */
export type PostgresClusterAttachmentEdge = {
  __typename?: 'PostgresClusterAttachmentEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output']
  /** The item at the end of the edge. */
  node?: Maybe<PostgresClusterAttachment>
}

export type PostgresClusterDatabase = {
  __typename?: 'PostgresClusterDatabase'
  name: Scalars['String']['output']
  users: Array<Scalars['String']['output']>
}

export type PostgresClusterUser = {
  __typename?: 'PostgresClusterUser'
  databases: Array<Scalars['String']['output']>
  isSuperuser: Scalars['Boolean']['output']
  username: Scalars['String']['output']
}

export type PriceTier = {
  __typename?: 'PriceTier'
  unitAmount?: Maybe<Scalars['String']['output']>
  upTo?: Maybe<Scalars['BigInt']['output']>
}

export type Principal = {
  /** URL for avatar or placeholder */
  avatarUrl: Scalars['String']['output']
  /** @deprecated Use User fragment on Viewer instead */
  createdAt?: Maybe<Scalars['ISO8601DateTime']['output']>
  /** Email address for principal */
  email: Scalars['String']['output']
  /** @deprecated Use User fragment on Viewer instead */
  featureFlags?: Maybe<Array<Scalars['String']['output']>>
  /** @deprecated Use User fragment on Viewer instead */
  hasNodeproxyApps?: Maybe<Scalars['Boolean']['output']>
  /** @deprecated Use User fragment on Viewer instead */
  id?: Maybe<Scalars['ID']['output']>
  /** @deprecated Use User fragment on Viewer instead */
  lastRegion?: Maybe<Scalars['String']['output']>
  /** Display name of principal */
  name?: Maybe<Scalars['String']['output']>
  /** @deprecated Use User fragment on Viewer instead */
  organizations?: Maybe<OrganizationConnection>
  /** @deprecated Use User fragment on Viewer instead */
  personalOrganization?: Maybe<Organization>
  trust: OrganizationTrust
  /** @deprecated Use User fragment on Viewer instead */
  twoFactorProtection?: Maybe<Scalars['Boolean']['output']>
  /** @deprecated Use User fragment on Viewer instead */
  username?: Maybe<Scalars['String']['output']>
}

export type PrincipalOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

export type ProcessGroup = {
  __typename?: 'ProcessGroup'
  maxPerRegion: Scalars['Int']['output']
  name: Scalars['String']['output']
  regions: Array<Scalars['String']['output']>
  vmSize: VmSize
}

export type Product = {
  __typename?: 'Product'
  name: Scalars['String']['output']
  tiers: Array<PriceTier>
  type: Scalars['String']['output']
  unitLabel?: Maybe<Scalars['String']['output']>
}

export type PropertyInput = {
  /** The name of the property */
  name: Scalars['String']['input']
  /** The value of the property */
  value?: InputMaybe<Scalars['String']['input']>
}

export type Queries = {
  __typename?: 'Queries'
  accessTokens: AccessTokenConnection
  /** Find an add-on by ID or name */
  addOn?: Maybe<AddOn>
  /** List add-on service plans */
  addOnPlans: AddOnPlanConnection
  addOnProvider: AddOnProvider
  /** List add-ons associated with an organization */
  addOns: AddOnConnection
  /** Find an app by name */
  app?: Maybe<App>
  /** List apps */
  apps: AppConnection
  /** Verifies if an app can undergo a bluegreen deployment */
  canPerformBluegreenDeployment: Scalars['Boolean']['output']
  /** Find a certificate by ID */
  certificate?: Maybe<AppCertificate>
  checkJobs: CheckJobConnection
  checkLocations: Array<CheckLocation>
  /** @deprecated use viewer instead */
  currentUser: User
  /** Find a domain by name */
  domain?: Maybe<Domain>
  /** @deprecated deprecated */
  githubIntegration: GithubIntegration
  herokuIntegration: HerokuIntegration
  /** Find an ip address by ID */
  ipAddress?: Maybe<IpAddress>
  /** Returns the latest available tag for a given image repository */
  latestImageDetails: ImageVersion
  /** Returns the latest available tag for a given image repository */
  latestImageTag: Scalars['String']['output']
  /** Get a single machine */
  machine: Machine
  /** List machines */
  machines: MachineConnection
  nearestRegion: Region
  /** Fetches an object given its ID. */
  node?: Maybe<Node>
  /** Fetches a list of objects given a list of IDs. */
  nodes: Array<Maybe<Node>>
  /** Find an organization by ID */
  organization?: Maybe<Organization>
  organizations: OrganizationConnection
  personalOrganization: Organization
  /** fly.io platform information */
  platform: FlyPlatform
  /** List postgres attachments */
  postgresAttachments: PostgresClusterAttachmentConnection
  /** Fly.io product and price information */
  products: Array<Product>
  validateConfig: AppConfig
  viewer: Principal
  /** Find a persistent volume by ID */
  volume?: Maybe<Volume>
}

export type QueriesAccessTokensArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
  type?: InputMaybe<AccessTokenType>
}

export type QueriesAddOnArgs = {
  id?: InputMaybe<Scalars['ID']['input']>
  name?: InputMaybe<Scalars['String']['input']>
}

export type QueriesAddOnPlansArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

export type QueriesAddOnProviderArgs = {
  name: Scalars['String']['input']
}

export type QueriesAddOnsArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
  type?: InputMaybe<AddOnType>
}

export type QueriesAppArgs = {
  internalId?: InputMaybe<Scalars['String']['input']>
  name?: InputMaybe<Scalars['String']['input']>
}

export type QueriesAppsArgs = {
  active?: InputMaybe<Scalars['Boolean']['input']>
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
  organizationId?: InputMaybe<Scalars['ID']['input']>
  platform?: InputMaybe<Scalars['String']['input']>
  role?: InputMaybe<Scalars['String']['input']>
}

export type QueriesCanPerformBluegreenDeploymentArgs = {
  name: Scalars['String']['input']
}

export type QueriesCertificateArgs = {
  id: Scalars['ID']['input']
}

export type QueriesCheckJobsArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

export type QueriesDomainArgs = {
  name: Scalars['String']['input']
}

export type QueriesIpAddressArgs = {
  id: Scalars['ID']['input']
}

export type QueriesLatestImageDetailsArgs = {
  image: Scalars['String']['input']
}

export type QueriesLatestImageTagArgs = {
  repository: Scalars['String']['input']
  snapshotId?: InputMaybe<Scalars['ID']['input']>
}

export type QueriesMachineArgs = {
  machineId: Scalars['String']['input']
}

export type QueriesMachinesArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  appId?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
  state?: InputMaybe<Scalars['String']['input']>
  version?: InputMaybe<Scalars['Int']['input']>
}

export type QueriesNearestRegionArgs = {
  wireguardGateway?: InputMaybe<Scalars['Boolean']['input']>
}

export type QueriesNodeArgs = {
  id: Scalars['ID']['input']
}

export type QueriesNodesArgs = {
  ids: Array<Scalars['ID']['input']>
}

export type QueriesOrganizationArgs = {
  id?: InputMaybe<Scalars['ID']['input']>
  name?: InputMaybe<Scalars['String']['input']>
  slug?: InputMaybe<Scalars['String']['input']>
}

export type QueriesOrganizationsArgs = {
  admin?: InputMaybe<Scalars['Boolean']['input']>
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
  type?: InputMaybe<OrganizationType>
  withBillingIssuesOnly?: InputMaybe<Scalars['Boolean']['input']>
}

export type QueriesPostgresAttachmentsArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  appName?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
  postgresAppName: Scalars['String']['input']
}

export type QueriesValidateConfigArgs = {
  definition: Scalars['JSON']['input']
}

export type QueriesVolumeArgs = {
  id: Scalars['ID']['input']
}

export type Region = {
  __typename?: 'Region'
  /** The IATA airport code for this region */
  code: Scalars['String']['output']
  gatewayAvailable: Scalars['Boolean']['output']
  /** The latitude of this region */
  latitude?: Maybe<Scalars['Float']['output']>
  /** The longitude of this region */
  longitude?: Maybe<Scalars['Float']['output']>
  /** The name of this region */
  name: Scalars['String']['output']
  processGroup?: Maybe<Scalars['String']['output']>
  requiresPaidPlan: Scalars['Boolean']['output']
}

export enum RegionEnum {
  /** Amsterdam, NL */
  Ams = 'AMS',
  /** Atlanta, US */
  Atl = 'ATL',
  /** Dallas, US */
  Dfw = 'DFW',
  /** New York, US */
  Ewr = 'EWR',
  /** Frankfurt, DE */
  Fra = 'FRA',
  /** Hong Kong, CN */
  Hkg = 'HKG',
  /** Virginia, US */
  Iad = 'IAD',
  /** Los Angeles, US */
  Lax = 'LAX',
  /** Tokyo, JP */
  Nrt = 'NRT',
  /** Chicago, US */
  Ord = 'ORD',
  /** Seattle, US */
  Sea = 'SEA',
  /** Singapore, SG */
  Sin = 'SIN',
  /** San Jose, US */
  Sjc = 'SJC',
  /** Sydney, AU */
  Syd = 'SYD',
  /** Toronto, CA */
  Yyz = 'YYZ'
}

export type RegionPlacement = {
  __typename?: 'RegionPlacement'
  /** The desired number of allocations */
  count?: Maybe<Scalars['Int']['output']>
  /** The region code */
  region: Scalars['String']['output']
}

/** Autogenerated input type of RegisterDomain */
export type RegisterDomainInput = {
  /** Enable auto renew on the registration */
  autoRenew?: InputMaybe<Scalars['Boolean']['input']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The node ID of the domain */
  domainId: Scalars['ID']['input']
  /** Enable whois privacy on the registration */
  whoisPrivacy?: InputMaybe<Scalars['Boolean']['input']>
}

/** Autogenerated return type of RegisterDomain. */
export type RegisterDomainPayload = {
  __typename?: 'RegisterDomainPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  domain: Domain
}

export type Release = Node & {
  __typename?: 'Release'
  config?: Maybe<AppConfig>
  createdAt: Scalars['ISO8601DateTime']['output']
  deploymentStrategy: DeploymentStrategy
  /** A description of the release */
  description: Scalars['String']['output']
  evaluationId?: Maybe<Scalars['String']['output']>
  /** Unique ID */
  id: Scalars['ID']['output']
  /** Docker image */
  image?: Maybe<Image>
  /** Docker image URI */
  imageRef?: Maybe<Scalars['String']['output']>
  /** @deprecated use deployment.inProgress */
  inProgress: Scalars['Boolean']['output']
  /** The reason for the release */
  reason: Scalars['String']['output']
  /** Version release reverted to */
  revertedTo?: Maybe<Scalars['Int']['output']>
  stable: Scalars['Boolean']['output']
  /** The status of the release */
  status: Scalars['String']['output']
  updatedAt: Scalars['ISO8601DateTime']['output']
  /** The user who created the release */
  user?: Maybe<User>
  /** The version of the release */
  version: Scalars['Int']['output']
}

export type ReleaseCommand = Node & {
  __typename?: 'ReleaseCommand'
  app: App
  command: Scalars['String']['output']
  evaluationId?: Maybe<Scalars['String']['output']>
  exitCode?: Maybe<Scalars['Int']['output']>
  failed: Scalars['Boolean']['output']
  id: Scalars['ID']['output']
  inProgress: Scalars['Boolean']['output']
  instanceId?: Maybe<Scalars['String']['output']>
  status: Scalars['String']['output']
  succeeded: Scalars['Boolean']['output']
}

/** The connection type for Release. */
export type ReleaseConnection = {
  __typename?: 'ReleaseConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReleaseEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Release>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/** An edge in a connection. */
export type ReleaseEdge = {
  __typename?: 'ReleaseEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output']
  /** The item at the end of the edge. */
  node?: Maybe<Release>
}

/** Autogenerated input type of ReleaseIPAddress */
export type ReleaseIpAddressInput = {
  /** The ID of the app */
  appId?: InputMaybe<Scalars['ID']['input']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  ip?: InputMaybe<Scalars['String']['input']>
  /** The id of the ip address to release */
  ipAddressId?: InputMaybe<Scalars['ID']['input']>
}

/** Autogenerated return type of ReleaseIPAddress. */
export type ReleaseIpAddressPayload = {
  __typename?: 'ReleaseIPAddressPayload'
  app: App
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
}

export type ReleaseUnprocessed = Node & {
  __typename?: 'ReleaseUnprocessed'
  configDefinition?: Maybe<Scalars['JSON']['output']>
  createdAt: Scalars['ISO8601DateTime']['output']
  deploymentStrategy: DeploymentStrategy
  /** A description of the release */
  description: Scalars['String']['output']
  evaluationId?: Maybe<Scalars['String']['output']>
  /** Unique ID */
  id: Scalars['ID']['output']
  /** Docker image */
  image?: Maybe<Image>
  /** Docker image URI */
  imageRef?: Maybe<Scalars['String']['output']>
  /** @deprecated use deployment.inProgress */
  inProgress: Scalars['Boolean']['output']
  /** The reason for the release */
  reason: Scalars['String']['output']
  /** Version release reverted to */
  revertedTo?: Maybe<Scalars['Int']['output']>
  stable: Scalars['Boolean']['output']
  /** The status of the release */
  status: Scalars['String']['output']
  updatedAt: Scalars['ISO8601DateTime']['output']
  /** The user who created the release */
  user?: Maybe<User>
  /** The version of the release */
  version: Scalars['Int']['output']
}

/** The connection type for ReleaseUnprocessed. */
export type ReleaseUnprocessedConnection = {
  __typename?: 'ReleaseUnprocessedConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReleaseUnprocessedEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<ReleaseUnprocessed>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/** An edge in a connection. */
export type ReleaseUnprocessedEdge = {
  __typename?: 'ReleaseUnprocessedEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output']
  /** The item at the end of the edge. */
  node?: Maybe<ReleaseUnprocessed>
}

export type RemoteDockerBuilderAppRole = AppRole & {
  __typename?: 'RemoteDockerBuilderAppRole'
  /** The name of this role */
  name: Scalars['String']['output']
}

/** Autogenerated input type of RemoveMachine */
export type RemoveMachineInput = {
  /** The ID of the app */
  appId?: InputMaybe<Scalars['ID']['input']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** machine id */
  id: Scalars['String']['input']
  /** force kill machine if it's running */
  kill?: InputMaybe<Scalars['Boolean']['input']>
}

/** Autogenerated return type of RemoveMachine. */
export type RemoveMachinePayload = {
  __typename?: 'RemoveMachinePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  machine: Machine
}

/** Autogenerated input type of RemoveWireGuardPeer */
export type RemoveWireGuardPeerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The name of the peer to remove */
  name: Scalars['String']['input']
  /** Add via NATS transaction (for testing only, nosy users) */
  nats?: InputMaybe<Scalars['Boolean']['input']>
  /** The node ID of the organization */
  organizationId: Scalars['ID']['input']
}

/** Autogenerated return type of RemoveWireGuardPeer. */
export type RemoveWireGuardPeerPayload = {
  __typename?: 'RemoveWireGuardPeerPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  /** The organization that owned the peer */
  organization: Organization
}

/** Autogenerated input type of ResetAddOnPassword */
export type ResetAddOnPasswordInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The ID of the add-on whose password should be reset */
  name: Scalars['String']['input']
}

/** Autogenerated return type of ResetAddOnPassword. */
export type ResetAddOnPasswordPayload = {
  __typename?: 'ResetAddOnPasswordPayload'
  addOn: AddOn
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
}

/** Autogenerated input type of RestartAllocation */
export type RestartAllocationInput = {
  /** The ID of the app */
  allocId: Scalars['ID']['input']
  /** The ID of the app */
  appId: Scalars['ID']['input']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
}

/** Autogenerated return type of RestartAllocation. */
export type RestartAllocationPayload = {
  __typename?: 'RestartAllocationPayload'
  allocation: Allocation
  app: App
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
}

/** Autogenerated input type of RestartApp */
export type RestartAppInput = {
  /** The ID of the app */
  appId: Scalars['ID']['input']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
}

/** Autogenerated return type of RestartApp. */
export type RestartAppPayload = {
  __typename?: 'RestartAppPayload'
  app: App
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
}

/** Autogenerated input type of RestoreVolumeSnapshot */
export type RestoreVolumeSnapshotInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  snapshotId: Scalars['ID']['input']
  volumeId: Scalars['ID']['input']
}

/** Autogenerated return type of RestoreVolumeSnapshot. */
export type RestoreVolumeSnapshotPayload = {
  __typename?: 'RestoreVolumeSnapshotPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  snapshot: VolumeSnapshot
  volume: Volume
}

/** Autogenerated input type of ResumeApp */
export type ResumeAppInput = {
  /** The ID of the app */
  appId: Scalars['ID']['input']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
}

/** Autogenerated return type of ResumeApp. */
export type ResumeAppPayload = {
  __typename?: 'ResumeAppPayload'
  app: App
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
}

/** Autogenerated input type of RevokePostgresClusterUserAccess */
export type RevokePostgresClusterUserAccessInput = {
  /** The name of the postgres cluster app */
  appName: Scalars['String']['input']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The database to revoke access to */
  databaseName: Scalars['String']['input']
  /** The username to revoke */
  username: Scalars['String']['input']
}

/** Autogenerated return type of RevokePostgresClusterUserAccess. */
export type RevokePostgresClusterUserAccessPayload = {
  __typename?: 'RevokePostgresClusterUserAccessPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  database: PostgresClusterDatabase
  postgresClusterRole: PostgresClusterAppRole
  user: PostgresClusterUser
}

export enum RuntimeType {
  /** Fly Container Runtime */
  Firecracker = 'FIRECRACKER',
  /** Fly JavaScript Runtime */
  Nodeproxy = 'NODEPROXY'
}

/** Autogenerated input type of SaveDeploymentSource */
export type SaveDeploymentSourceInput = {
  /** The application to update */
  appId: Scalars['String']['input']
  baseDir?: InputMaybe<Scalars['String']['input']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  provider: Scalars['String']['input']
  ref?: InputMaybe<Scalars['String']['input']>
  repositoryId: Scalars['String']['input']
  skipBuild?: InputMaybe<Scalars['Boolean']['input']>
}

/** Autogenerated return type of SaveDeploymentSource. */
export type SaveDeploymentSourcePayload = {
  __typename?: 'SaveDeploymentSourcePayload'
  app?: Maybe<App>
  build?: Maybe<Build>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
}

/** Autogenerated input type of ScaleApp */
export type ScaleAppInput = {
  /** The ID of the app */
  appId: Scalars['ID']['input']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** Regions to scale */
  regions: Array<ScaleRegionInput>
}

/** Autogenerated return type of ScaleApp. */
export type ScaleAppPayload = {
  __typename?: 'ScaleAppPayload'
  app: App
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  delta: Array<ScaleRegionChange>
  placement: Array<RegionPlacement>
}

export type ScaleRegionChange = {
  __typename?: 'ScaleRegionChange'
  /** The original value */
  fromCount: Scalars['Int']['output']
  /** The region code */
  region: Scalars['String']['output']
  /** The new value */
  toCount?: Maybe<Scalars['Int']['output']>
}

/** Region placement configuration */
export type ScaleRegionInput = {
  /** The value to change by */
  count: Scalars['Int']['input']
  /** The region to configure */
  region: Scalars['String']['input']
}

export enum SchedulingEnum {
  /** Ephemeral app, stays stopped on exit */
  Ephemeral = 'EPHEMERAL',
  /** Permanent app, restarts on exit */
  Permanent = 'PERMANENT'
}

export type Secret = Node & {
  __typename?: 'Secret'
  createdAt: Scalars['ISO8601DateTime']['output']
  /** The digest of the secret value */
  digest: Scalars['String']['output']
  id: Scalars['ID']['output']
  /** The name of the secret */
  name: Scalars['String']['output']
  /** The user who initiated the deployment */
  user?: Maybe<User>
}

/** A secure configuration value */
export type SecretInput = {
  /** The unqiue key for this secret */
  key: Scalars['String']['input']
  /** The value of this secret */
  value: Scalars['String']['input']
}

/** Global port routing */
export type Service = {
  __typename?: 'Service'
  /** Health checks */
  checks: Array<Check>
  description: Scalars['String']['output']
  /** Hard concurrency limit */
  hardConcurrency: Scalars['Int']['output']
  /** Application port to forward traffic to */
  internalPort: Scalars['Int']['output']
  /** Ports to listen on */
  ports: Array<ServicePort>
  /** Protocol to listen on */
  protocol: ServiceProtocolType
  /** Soft concurrency limit */
  softConcurrency: Scalars['Int']['output']
}

export enum ServiceHandlerType {
  /** Convert TCP connection to HTTP (at the edge) */
  EdgeHttp = 'EDGE_HTTP',
  /** Convert TCP connection to HTTP */
  Http = 'HTTP',
  /** Handle TLS for PostgreSQL connections */
  PgTls = 'PG_TLS',
  /** Wrap TCP connection in PROXY protocol */
  ProxyProto = 'PROXY_PROTO',
  /** Convert TLS connection to unencrypted TCP */
  Tls = 'TLS'
}

/** Global port routing */
export type ServiceInput = {
  /** Health checks */
  checks?: InputMaybe<Array<CheckInput>>
  /** Hard concurrency limit */
  hardConcurrency?: InputMaybe<Scalars['Int']['input']>
  /** Application port to forward traffic to */
  internalPort: Scalars['Int']['input']
  /** Ports to listen on */
  ports?: InputMaybe<Array<ServiceInputPort>>
  /** Protocol to listen on */
  protocol: ServiceProtocolType
  /** Soft concurrency limit */
  softConcurrency?: InputMaybe<Scalars['Int']['input']>
}

/** Service port */
export type ServiceInputPort = {
  /** Handlers to apply before forwarding service traffic */
  handlers?: InputMaybe<Array<ServiceHandlerType>>
  /** Port to listen on */
  port: Scalars['Int']['input']
  /** tls options */
  tlsOptions?: InputMaybe<ServicePortTlsOptionsInput>
}

/** Service port */
export type ServicePort = {
  __typename?: 'ServicePort'
  /** End port for range */
  endPort?: Maybe<Scalars['Int']['output']>
  /** Handlers to apply before forwarding service traffic */
  handlers: Array<ServiceHandlerType>
  /** Port to listen on */
  port?: Maybe<Scalars['Int']['output']>
  /** Start port for range */
  startPort?: Maybe<Scalars['Int']['output']>
}

/** TLS handshakes options for a port */
export type ServicePortTlsOptionsInput = {
  defaultSelfSigned?: InputMaybe<Scalars['Boolean']['input']>
}

export enum ServiceProtocolType {
  /** TCP protocol */
  Tcp = 'TCP',
  /** UDP protocl */
  Udp = 'UDP'
}

/** Autogenerated input type of SetAppsv2DefaultOn */
export type SetAppsv2DefaultOnInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** Whether or not new apps in this org use Apps V2 by default */
  defaultOn: Scalars['Boolean']['input']
  /** The organization slug */
  organizationSlug: Scalars['String']['input']
}

/** Autogenerated return type of SetAppsv2DefaultOn. */
export type SetAppsv2DefaultOnPayload = {
  __typename?: 'SetAppsv2DefaultOnPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  organization: Organization
}

/** Autogenerated input type of SetPagerdutyHandler */
export type SetPagerdutyHandlerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** Handler name */
  name: Scalars['String']['input']
  /** The node ID of the organization */
  organizationId: Scalars['ID']['input']
  /** Map of alert severity levels to PagerDuty severity levels */
  pagerdutyStatusMap?: InputMaybe<Scalars['JSON']['input']>
  /** PagerDuty API token */
  pagerdutyToken: Scalars['String']['input']
}

/** Autogenerated return type of SetPagerdutyHandler. */
export type SetPagerdutyHandlerPayload = {
  __typename?: 'SetPagerdutyHandlerPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  handler: HealthCheckHandler
}

/** Autogenerated input type of SetPlatformVersion */
export type SetPlatformVersionInput = {
  /** The ID of the app */
  appId: Scalars['ID']['input']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** Unique lock ID */
  lockId?: InputMaybe<Scalars['ID']['input']>
  /** nomad or machines */
  platformVersion: Scalars['String']['input']
}

/** Autogenerated return type of SetPlatformVersion. */
export type SetPlatformVersionPayload = {
  __typename?: 'SetPlatformVersionPayload'
  app: App
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
}

/** Autogenerated input type of SetSecrets */
export type SetSecretsInput = {
  /** The ID of the app */
  appId: Scalars['ID']['input']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** By default, we set only the secrets you specify. Set this to true to replace all secrets. */
  replaceAll?: InputMaybe<Scalars['Boolean']['input']>
  /** Secrets to set */
  secrets: Array<SecretInput>
}

/** Autogenerated return type of SetSecrets. */
export type SetSecretsPayload = {
  __typename?: 'SetSecretsPayload'
  app: App
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  release?: Maybe<Release>
}

/** Autogenerated input type of SetSlackHandler */
export type SetSlackHandlerInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** Handler name */
  name: Scalars['String']['input']
  /** The node ID of the organization */
  organizationId: Scalars['ID']['input']
  /** Slack channel to send messages to, defaults to #general */
  slackChannel?: InputMaybe<Scalars['String']['input']>
  /** Icon to show with Slack messages */
  slackIconUrl?: InputMaybe<Scalars['String']['input']>
  /** User name to display on Slack Messages (defaults to Fly) */
  slackUsername?: InputMaybe<Scalars['String']['input']>
  /** Slack Webhook URL to use for health check notifications */
  slackWebhookUrl: Scalars['String']['input']
}

/** Autogenerated return type of SetSlackHandler. */
export type SetSlackHandlerPayload = {
  __typename?: 'SetSlackHandlerPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  handler: HealthCheckHandler
}

/** Autogenerated input type of SetVMCount */
export type SetVmCountInput = {
  /** The ID of the app */
  appId: Scalars['ID']['input']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** Counts for VM groups */
  groupCounts: Array<VmCountInput>
  /** Unique lock ID */
  lockId?: InputMaybe<Scalars['ID']['input']>
}

/** Autogenerated return type of SetVMCount. */
export type SetVmCountPayload = {
  __typename?: 'SetVMCountPayload'
  app: App
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  release?: Maybe<Release>
  taskGroupCounts: Array<TaskGroupCount>
  warnings: Array<Scalars['String']['output']>
}

/** Autogenerated input type of SetVMSize */
export type SetVmSizeInput = {
  /** The ID of the app */
  appId: Scalars['ID']['input']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** Process group to modify */
  group?: InputMaybe<Scalars['String']['input']>
  /** Optionally request more memory */
  memoryMb?: InputMaybe<Scalars['Int']['input']>
  /** The name of the vm size to set */
  sizeName: Scalars['String']['input']
}

/** Autogenerated return type of SetVMSize. */
export type SetVmSizePayload = {
  __typename?: 'SetVMSizePayload'
  app: App
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  /** Process Group scale change applied to (if any) */
  processGroup?: Maybe<ProcessGroup>
  /** Default app vm size */
  vmSize?: Maybe<VmSize>
}

/** Autogenerated input type of StartBuild */
export type StartBuildInput = {
  /** The ID of the app */
  appId: Scalars['ID']['input']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
}

/** Autogenerated return type of StartBuild. */
export type StartBuildPayload = {
  __typename?: 'StartBuildPayload'
  build: Build
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
}

/** Autogenerated input type of StartMachine */
export type StartMachineInput = {
  /** The ID of the app */
  appId?: InputMaybe<Scalars['ID']['input']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** machine id */
  id: Scalars['String']['input']
}

/** Autogenerated return type of StartMachine. */
export type StartMachinePayload = {
  __typename?: 'StartMachinePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  machine: Machine
}

/** Autogenerated input type of StopAllocation */
export type StopAllocationInput = {
  /** The ID of the app */
  allocId: Scalars['ID']['input']
  /** The ID of the app */
  appId: Scalars['ID']['input']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
}

/** Autogenerated return type of StopAllocation. */
export type StopAllocationPayload = {
  __typename?: 'StopAllocationPayload'
  allocation: Allocation
  app: App
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
}

/** Autogenerated input type of StopMachine */
export type StopMachineInput = {
  /** The ID of the app */
  appId?: InputMaybe<Scalars['ID']['input']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** machine id */
  id: Scalars['String']['input']
  /** how long to wait before force killing the machine */
  killTimeoutSecs?: InputMaybe<Scalars['Int']['input']>
  /** signal to send the machine */
  signal?: InputMaybe<Scalars['String']['input']>
}

/** Autogenerated return type of StopMachine. */
export type StopMachinePayload = {
  __typename?: 'StopMachinePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  machine: Machine
}

export type TaskGroupCount = {
  __typename?: 'TaskGroupCount'
  count: Scalars['Int']['output']
  name: Scalars['String']['output']
}

export type TemplateDeployment = Node & {
  __typename?: 'TemplateDeployment'
  apps: AppConnection
  id: Scalars['ID']['output']
  organization: Organization
  status: Scalars['String']['output']
}

export type TemplateDeploymentAppsArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

/** Autogenerated input type of UnlockApp */
export type UnlockAppInput = {
  /** The ID of the app */
  appId: Scalars['ID']['input']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** Unique lock ID */
  lockId: Scalars['ID']['input']
}

/** Autogenerated return type of UnlockApp. */
export type UnlockAppPayload = {
  __typename?: 'UnlockAppPayload'
  app: App
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
}

/** Autogenerated input type of UnsetSecrets */
export type UnsetSecretsInput = {
  /** The ID of the app */
  appId: Scalars['ID']['input']
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** Secret keys to unset */
  keys: Array<Scalars['String']['input']>
}

/** Autogenerated return type of UnsetSecrets. */
export type UnsetSecretsPayload = {
  __typename?: 'UnsetSecretsPayload'
  app: App
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  release?: Maybe<Release>
}

/** Autogenerated input type of UpdateAddOn */
export type UpdateAddOnInput = {
  /** The add-on ID to update */
  addOnId?: InputMaybe<Scalars['ID']['input']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The add-on name to update */
  name?: InputMaybe<Scalars['String']['input']>
  /** Options specific to the add-on */
  options?: InputMaybe<Scalars['JSON']['input']>
  /** The add-on plan ID */
  planId?: InputMaybe<Scalars['ID']['input']>
  /** Desired regions to place replicas in */
  readRegions?: InputMaybe<Array<Scalars['String']['input']>>
}

/** Autogenerated return type of UpdateAddOn. */
export type UpdateAddOnPayload = {
  __typename?: 'UpdateAddOnPayload'
  addOn: AddOn
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
}

/** Autogenerated input type of UpdateAutoscaleConfig */
export type UpdateAutoscaleConfigInput = {
  /** The ID of the app */
  appId: Scalars['ID']['input']
  balanceRegions?: InputMaybe<Scalars['Boolean']['input']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  enabled?: InputMaybe<Scalars['Boolean']['input']>
  maxCount?: InputMaybe<Scalars['Int']['input']>
  minCount?: InputMaybe<Scalars['Int']['input']>
  /** Region configs */
  regions?: InputMaybe<Array<AutoscaleRegionConfigInput>>
  resetRegions?: InputMaybe<Scalars['Boolean']['input']>
}

/** Autogenerated return type of UpdateAutoscaleConfig. */
export type UpdateAutoscaleConfigPayload = {
  __typename?: 'UpdateAutoscaleConfigPayload'
  app: App
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
}

/** Autogenerated input type of UpdateDNSPortal */
export type UpdateDnsPortalInput = {
  /** The secondary branding color */
  accentColor?: InputMaybe<Scalars['String']['input']>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The node ID of the organization */
  dnsPortalId: Scalars['ID']['input']
  /** The unique name of this portal. */
  name?: InputMaybe<Scalars['String']['input']>
  /** The primary branding color */
  primaryColor?: InputMaybe<Scalars['String']['input']>
  /** The return url for this portal */
  returnUrl?: InputMaybe<Scalars['String']['input']>
  /** The text to display for the return url link */
  returnUrlText?: InputMaybe<Scalars['String']['input']>
  /** The support url for this portal */
  supportUrl?: InputMaybe<Scalars['String']['input']>
  /** The text to display for the support url link */
  supportUrlText?: InputMaybe<Scalars['String']['input']>
  /** The title of this portal */
  title?: InputMaybe<Scalars['String']['input']>
}

/** Autogenerated return type of UpdateDNSPortal. */
export type UpdateDnsPortalPayload = {
  __typename?: 'UpdateDNSPortalPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  dnsPortal: DnsPortal
}

/** Autogenerated input type of UpdateDNSRecord */
export type UpdateDnsRecordInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The dns record name */
  name?: InputMaybe<Scalars['String']['input']>
  /** The content of the record */
  rdata?: InputMaybe<Scalars['String']['input']>
  /** The node ID of the DNS record */
  recordId: Scalars['ID']['input']
  /** The TTL in seconds */
  ttl?: InputMaybe<Scalars['Int']['input']>
}

/** Autogenerated return type of UpdateDNSRecord. */
export type UpdateDnsRecordPayload = {
  __typename?: 'UpdateDNSRecordPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  record: DnsRecord
}

/** Autogenerated input type of UpdateDNSRecords */
export type UpdateDnsRecordsInput = {
  changes: Array<DnsRecordChangeInput>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The node ID of the domain */
  domainId: Scalars['ID']['input']
}

/** Autogenerated return type of UpdateDNSRecords. */
export type UpdateDnsRecordsPayload = {
  __typename?: 'UpdateDNSRecordsPayload'
  changes: Array<DnsRecordDiff>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  domain: Domain
  warnings: Array<DnsRecordWarning>
}

/** Autogenerated input type of UpdateOrganizationMembership */
export type UpdateOrganizationMembershipInput = {
  /** The new alert settings for the user */
  alertsEnabled?: InputMaybe<OrganizationAlertsEnabled>
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The node ID of the organization */
  organizationId: Scalars['ID']['input']
  /** The new role for the user */
  role: OrganizationMemberRole
  /** The node ID of the user */
  userId: Scalars['ID']['input']
}

/** Autogenerated return type of UpdateOrganizationMembership. */
export type UpdateOrganizationMembershipPayload = {
  __typename?: 'UpdateOrganizationMembershipPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  organization: Organization
  user: User
}

/** Autogenerated input type of UpdateRelease */
export type UpdateReleaseInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** The ID of the release */
  releaseId: Scalars['ID']['input']
  /** The new status for the release */
  status: Scalars['String']['input']
}

/** Autogenerated return type of UpdateRelease. */
export type UpdateReleasePayload = {
  __typename?: 'UpdateReleasePayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  release: Release
}

/** Autogenerated input type of UpdateRemoteBuilder */
export type UpdateRemoteBuilderInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  /** Docker image reference */
  image: Scalars['String']['input']
  /** The node ID of the organization */
  organizationId: Scalars['ID']['input']
}

/** Autogenerated return type of UpdateRemoteBuilder. */
export type UpdateRemoteBuilderPayload = {
  __typename?: 'UpdateRemoteBuilderPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  organization: Organization
}

export type User = Node &
  Principal & {
    __typename?: 'User'
    /** URL for avatar or placeholder */
    avatarUrl: Scalars['String']['output']
    createdAt: Scalars['ISO8601DateTime']['output']
    /** Email address for user (private) */
    email: Scalars['String']['output']
    /** Whether to create new organizations under Hobby plan */
    enablePaidHobby: Scalars['Boolean']['output']
    featureFlags: Array<Scalars['String']['output']>
    hasNodeproxyApps: Scalars['Boolean']['output']
    id: Scalars['ID']['output']
    lastRegion?: Maybe<Scalars['String']['output']>
    /** Display / full name for user (private) */
    name?: Maybe<Scalars['String']['output']>
    /** @deprecated Use query.organizations instead */
    organizations: OrganizationConnection
    /** @deprecated Use query.personalOrganization instead */
    personalOrganization: Organization
    trust: OrganizationTrust
    twoFactorProtection: Scalars['Boolean']['output']
    /** Public username for user */
    username?: Maybe<Scalars['String']['output']>
  }

export type UserOrganizationsArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

export type UserCoupon = Node & {
  __typename?: 'UserCoupon'
  createdAt: Scalars['ISO8601DateTime']['output']
  id: Scalars['ID']['output']
  /** Organization that owns this app */
  organization: Organization
  updatedAt: Scalars['ISO8601DateTime']['output']
}

export type Vm = Node & {
  __typename?: 'VM'
  attachedVolumes: VolumeConnection
  canary: Scalars['Boolean']['output']
  checks: Array<CheckState>
  createdAt: Scalars['ISO8601DateTime']['output']
  criticalCheckCount: Scalars['Int']['output']
  /** Desired status */
  desiredStatus: Scalars['String']['output']
  events: Array<AllocationEvent>
  failed: Scalars['Boolean']['output']
  healthy: Scalars['Boolean']['output']
  /** Unique ID for this instance */
  id: Scalars['ID']['output']
  /** Short unique ID for this instance */
  idShort: Scalars['ID']['output']
  /** Indicates if this instance is from the latest job version */
  latestVersion: Scalars['Boolean']['output']
  passingCheckCount: Scalars['Int']['output']
  /** Private IPv6 address for this instance */
  privateIP?: Maybe<Scalars['String']['output']>
  recentLogs: Array<LogEntry>
  /** Region this allocation is running in */
  region: Scalars['String']['output']
  restarts: Scalars['Int']['output']
  /** Current status */
  status: Scalars['String']['output']
  taskName: Scalars['String']['output']
  totalCheckCount: Scalars['Int']['output']
  transitioning: Scalars['Boolean']['output']
  updatedAt: Scalars['ISO8601DateTime']['output']
  /** The configuration version of this instance */
  version: Scalars['Int']['output']
  warningCheckCount: Scalars['Int']['output']
}

export type VmAttachedVolumesArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

export type VmChecksArgs = {
  name?: InputMaybe<Scalars['String']['input']>
}

export type VmRecentLogsArgs = {
  limit?: InputMaybe<Scalars['Int']['input']>
  range?: InputMaybe<Scalars['Int']['input']>
}

/** The connection type for VM. */
export type VmConnection = {
  __typename?: 'VMConnection'
  activeCount: Scalars['Int']['output']
  completeCount: Scalars['Int']['output']
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VmEdge>>>
  failedCount: Scalars['Int']['output']
  inactiveCount: Scalars['Int']['output']
  lostCount: Scalars['Int']['output']
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Vm>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  pendingCount: Scalars['Int']['output']
  runningCount: Scalars['Int']['output']
  totalCount: Scalars['Int']['output']
}

export type VmCountInput = {
  /** The desired count */
  count?: InputMaybe<Scalars['Int']['input']>
  /** VM group name */
  group?: InputMaybe<Scalars['String']['input']>
  /** Max number of VMs to allow per region */
  maxPerRegion?: InputMaybe<Scalars['Int']['input']>
}

/** An edge in a connection. */
export type VmEdge = {
  __typename?: 'VMEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output']
  /** The item at the end of the edge. */
  node?: Maybe<Vm>
}

export type VmSize = {
  __typename?: 'VMSize'
  cpuCores: Scalars['Float']['output']
  maxMemoryMb: Scalars['Int']['output']
  memoryGb: Scalars['Float']['output']
  memoryIncrementsMb: Array<Scalars['Int']['output']>
  memoryMb: Scalars['Int']['output']
  name: Scalars['String']['output']
  priceMonth: Scalars['Float']['output']
  priceSecond: Scalars['Float']['output']
}

export enum VmSizeEnum {
  /** Dedicated 1x CPU core, 2GB */
  DedicatedCpu_1X = 'DEDICATED_CPU_1X',
  /** Dedicated 2x CPU core, 4GB */
  DedicatedCpu_2X = 'DEDICATED_CPU_2X',
  /** Dedicated 4x CPU core, 8GB */
  DedicatedCpu_4X = 'DEDICATED_CPU_4X',
  /** Dedicated 8x CPU core, 16GB */
  DedicatedCpu_8X = 'DEDICATED_CPU_8X',
  /** Shared 1x CPU core, 256MB */
  SharedCpu_1X = 'SHARED_CPU_1X'
}

/** Autogenerated input type of ValidateWireGuardPeers */
export type ValidateWireGuardPeersInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']['input']>
  peerIps: Array<Scalars['String']['input']>
}

/** Autogenerated return type of ValidateWireGuardPeers. */
export type ValidateWireGuardPeersPayload = {
  __typename?: 'ValidateWireGuardPeersPayload'
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']['output']>
  invalidPeerIps: Array<Scalars['String']['output']>
  validPeerIps: Array<Scalars['String']['output']>
}

export type Volume = Node & {
  __typename?: 'Volume'
  app: App
  attachedAllocation?: Maybe<Allocation>
  attachedAllocationId?: Maybe<Scalars['String']['output']>
  attachedMachine?: Maybe<Machine>
  createdAt: Scalars['ISO8601DateTime']['output']
  encrypted: Scalars['Boolean']['output']
  host: Host
  id: Scalars['ID']['output']
  internalId: Scalars['String']['output']
  name: Scalars['String']['output']
  region: Scalars['String']['output']
  sizeGb: Scalars['Int']['output']
  snapshots: VolumeSnapshotConnection
  state: Scalars['String']['output']
  status: Scalars['String']['output']
  usedBytes: Scalars['BigInt']['output']
}

export type VolumeSnapshotsArgs = {
  after?: InputMaybe<Scalars['String']['input']>
  before?: InputMaybe<Scalars['String']['input']>
  first?: InputMaybe<Scalars['Int']['input']>
  last?: InputMaybe<Scalars['Int']['input']>
}

/** The connection type for Volume. */
export type VolumeConnection = {
  __typename?: 'VolumeConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VolumeEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<Volume>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/** An edge in a connection. */
export type VolumeEdge = {
  __typename?: 'VolumeEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output']
  /** The item at the end of the edge. */
  node?: Maybe<Volume>
}

export type VolumeInput = {
  /** How many volumes to create with this configuration */
  count?: InputMaybe<Scalars['Int']['input']>
  /** Volume should be encrypted at rest */
  encrypted?: InputMaybe<Scalars['Boolean']['input']>
  /** Volume name */
  name: Scalars['String']['input']
  /** Desired region for volume */
  region: RegionEnum
  /** Desired volume size, in GB */
  sizeGb: Scalars['Int']['input']
}

export type VolumeSnapshot = Node & {
  __typename?: 'VolumeSnapshot'
  createdAt: Scalars['ISO8601DateTime']['output']
  digest: Scalars['String']['output']
  id: Scalars['ID']['output']
  size: Scalars['BigInt']['output']
  volume: Volume
}

/** The connection type for VolumeSnapshot. */
export type VolumeSnapshotConnection = {
  __typename?: 'VolumeSnapshotConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<VolumeSnapshotEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<VolumeSnapshot>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/** An edge in a connection. */
export type VolumeSnapshotEdge = {
  __typename?: 'VolumeSnapshotEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output']
  /** The item at the end of the edge. */
  node?: Maybe<VolumeSnapshot>
}

export type WireGuardPeer = Node & {
  __typename?: 'WireGuardPeer'
  id: Scalars['ID']['output']
  name: Scalars['String']['output']
  network?: Maybe<Scalars['String']['output']>
  peerip: Scalars['String']['output']
  pubkey: Scalars['String']['output']
  region: Scalars['String']['output']
}

/** The connection type for WireGuardPeer. */
export type WireGuardPeerConnection = {
  __typename?: 'WireGuardPeerConnection'
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<WireGuardPeerEdge>>>
  /** A list of nodes. */
  nodes?: Maybe<Array<Maybe<WireGuardPeer>>>
  /** Information to aid in pagination. */
  pageInfo: PageInfo
  totalCount: Scalars['Int']['output']
}

/** An edge in a connection. */
export type WireGuardPeerEdge = {
  __typename?: 'WireGuardPeerEdge'
  /** A cursor for use in pagination. */
  cursor: Scalars['String']['output']
  /** The item at the end of the edge. */
  node?: Maybe<WireGuardPeer>
}

export type GetOrganizationByNameQueryVariables = Exact<{
  name: Scalars['String']['input']
}>

export type GetOrganizationByNameQuery = {
  __typename?: 'Queries'
  organization?: {
    __typename?: 'Organization'
    id: string
    name: string
    paidPlan: boolean
  } | null
}

export type ListAppsForOrganizationQueryVariables = Exact<{
  orgId: Scalars['ID']['input']
}>

export type ListAppsForOrganizationQuery = {
  __typename?: 'Queries'
  apps: {
    __typename?: 'AppConnection'
    nodes?: Array<{
      __typename?: 'App'
      id: string
      name: string
    } | null> | null
  }
}

export type DeployImageMutationVariables = Exact<{
  appId: Scalars['ID']['input']
  img: Scalars['String']['input']
  definition: Scalars['JSON']['input']
}>

export type DeployImageMutation = {
  __typename?: 'Mutations'
  deployImage?: {
    __typename?: 'DeployImagePayload'
    app: { __typename?: 'App'; id: string }
    release?: { __typename?: 'Release'; status: string } | null
  } | null
}

export type CreateAppMutationVariables = Exact<{
  input: CreateAppInput
}>

export type CreateAppMutation = {
  __typename?: 'Mutations'
  createApp?: {
    __typename?: 'CreateAppPayload'
    app: { __typename?: 'App'; id: string; name: string }
  } | null
}

export type SetSecretsMutationVariables = Exact<{
  appId: Scalars['ID']['input']
  secrets: Array<SecretInput> | SecretInput
}>

export type SetSecretsMutation = {
  __typename?: 'Mutations'
  setSecrets?: {
    __typename?: 'SetSecretsPayload'
    app: { __typename?: 'App'; state: AppState }
  } | null
}

export type DeleteAppMutationVariables = Exact<{
  appID: Scalars['ID']['input']
}>

export type DeleteAppMutation = {
  __typename?: 'Mutations'
  deleteApp?: {
    __typename?: 'DeleteAppPayload'
    organization: { __typename?: 'Organization'; name: string; id: string }
  } | null
}

export const GetOrganizationByNameDocument = gql`
  query GetOrganizationByName($name: String!) {
    organization(name: $name) {
      id
      name
      paidPlan
    }
  }
`
export const ListAppsForOrganizationDocument = gql`
  query ListAppsForOrganization($orgId: ID!) {
    apps(organizationId: $orgId) {
      nodes {
        id
        name
      }
    }
  }
`
export const DeployImageDocument = gql`
  mutation DeployImage($appId: ID!, $img: String!, $definition: JSON!) {
    deployImage(
      input: { image: $img, appId: $appId, definition: $definition }
    ) {
      app {
        id
      }
      release {
        status
      }
    }
  }
`
export const CreateAppDocument = gql`
  mutation CreateApp($input: CreateAppInput!) {
    createApp(input: $input) {
      app {
        id
        name
      }
    }
  }
`
export const SetSecretsDocument = gql`
  mutation SetSecrets($appId: ID!, $secrets: [SecretInput!]!) {
    setSecrets(input: { appId: $appId, secrets: $secrets, replaceAll: true }) {
      app {
        state
      }
    }
  }
`
export const DeleteAppDocument = gql`
  mutation DeleteApp($appID: ID!) {
    deleteApp(appId: $appID) {
      organization {
        name
        id
      }
    }
  }
`

export type SdkFunctionWrapper = <T>(
  action: (requestHeaders?: Record<string, string>) => Promise<T>,
  operationName: string,
  operationType?: string
) => Promise<T>

const defaultWrapper: SdkFunctionWrapper = (
  action,
  _operationName,
  _operationType
) => action()
const GetOrganizationByNameDocumentString = print(GetOrganizationByNameDocument)
const ListAppsForOrganizationDocumentString = print(
  ListAppsForOrganizationDocument
)
const DeployImageDocumentString = print(DeployImageDocument)
const CreateAppDocumentString = print(CreateAppDocument)
const SetSecretsDocumentString = print(SetSecretsDocument)
const DeleteAppDocumentString = print(DeleteAppDocument)
export function getSdk(
  client: GraphQLClient,
  withWrapper: SdkFunctionWrapper = defaultWrapper
) {
  return {
    GetOrganizationByName(
      variables: GetOrganizationByNameQueryVariables,
      requestHeaders?: GraphQLClientRequestHeaders
    ): Promise<{
      data: GetOrganizationByNameQuery
      errors?: GraphQLError[]
      extensions?: any
      headers: Headers
      status: number
    }> {
      return withWrapper(
        wrappedRequestHeaders =>
          client.rawRequest<GetOrganizationByNameQuery>(
            GetOrganizationByNameDocumentString,
            variables,
            { ...requestHeaders, ...wrappedRequestHeaders }
          ),
        'GetOrganizationByName',
        'query'
      )
    },
    ListAppsForOrganization(
      variables: ListAppsForOrganizationQueryVariables,
      requestHeaders?: GraphQLClientRequestHeaders
    ): Promise<{
      data: ListAppsForOrganizationQuery
      errors?: GraphQLError[]
      extensions?: any
      headers: Headers
      status: number
    }> {
      return withWrapper(
        wrappedRequestHeaders =>
          client.rawRequest<ListAppsForOrganizationQuery>(
            ListAppsForOrganizationDocumentString,
            variables,
            { ...requestHeaders, ...wrappedRequestHeaders }
          ),
        'ListAppsForOrganization',
        'query'
      )
    },
    DeployImage(
      variables: DeployImageMutationVariables,
      requestHeaders?: GraphQLClientRequestHeaders
    ): Promise<{
      data: DeployImageMutation
      errors?: GraphQLError[]
      extensions?: any
      headers: Headers
      status: number
    }> {
      return withWrapper(
        wrappedRequestHeaders =>
          client.rawRequest<DeployImageMutation>(
            DeployImageDocumentString,
            variables,
            { ...requestHeaders, ...wrappedRequestHeaders }
          ),
        'DeployImage',
        'mutation'
      )
    },
    CreateApp(
      variables: CreateAppMutationVariables,
      requestHeaders?: GraphQLClientRequestHeaders
    ): Promise<{
      data: CreateAppMutation
      errors?: GraphQLError[]
      extensions?: any
      headers: Headers
      status: number
    }> {
      return withWrapper(
        wrappedRequestHeaders =>
          client.rawRequest<CreateAppMutation>(
            CreateAppDocumentString,
            variables,
            { ...requestHeaders, ...wrappedRequestHeaders }
          ),
        'CreateApp',
        'mutation'
      )
    },
    SetSecrets(
      variables: SetSecretsMutationVariables,
      requestHeaders?: GraphQLClientRequestHeaders
    ): Promise<{
      data: SetSecretsMutation
      errors?: GraphQLError[]
      extensions?: any
      headers: Headers
      status: number
    }> {
      return withWrapper(
        wrappedRequestHeaders =>
          client.rawRequest<SetSecretsMutation>(
            SetSecretsDocumentString,
            variables,
            { ...requestHeaders, ...wrappedRequestHeaders }
          ),
        'SetSecrets',
        'mutation'
      )
    },
    DeleteApp(
      variables: DeleteAppMutationVariables,
      requestHeaders?: GraphQLClientRequestHeaders
    ): Promise<{
      data: DeleteAppMutation
      errors?: GraphQLError[]
      extensions?: any
      headers: Headers
      status: number
    }> {
      return withWrapper(
        wrappedRequestHeaders =>
          client.rawRequest<DeleteAppMutation>(
            DeleteAppDocumentString,
            variables,
            { ...requestHeaders, ...wrappedRequestHeaders }
          ),
        'DeleteApp',
        'mutation'
      )
    }
  }
}
export type Sdk = ReturnType<typeof getSdk>
